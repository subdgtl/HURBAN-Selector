diff --git a/benches/shrink_wrap.rs b/benches/shrink_wrap.rs
index 8de4e5c..42ec65e 100644
--- a/benches/shrink_wrap.rs
+++ b/benches/shrink_wrap.rs
@@ -6,7 +6,7 @@ use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criteri
 
 fn bench_shrink_wrap(c: &mut Criterion) {
     let mut group = c.benchmark_group("shrink_wrap");
-    let geometry = geometry::uv_sphere([0.0, 0.0, 0.0], 1.0, 3, 3);
+    let geometry = geometry::uv_sphere_geometry([0.0, 0.0, 0.0], 1.0, 3, 3);
 
     for density in (10u32..=50u32).step_by(10) {
         group.bench_with_input(
diff --git a/src/geometry.rs b/src/geometry.rs
index 5a4cd25..042ae70 100644
--- a/src/geometry.rs
+++ b/src/geometry.rs
@@ -1,5 +1,6 @@
 use std::cmp;
 use std::collections::HashSet;
+use std::f32;
 use std::fmt;
 use std::hash::{Hash, Hasher};
 use std::iter::IntoIterator;
@@ -7,7 +8,7 @@ use std::iter::IntoIterator;
 use arrayvec::ArrayVec;
 use nalgebra as na;
 use nalgebra::base::Vector3;
-use nalgebra::geometry::Point3;
+use nalgebra::Point3;
 
 use crate::convert::{cast_u32, cast_usize};
 
@@ -78,11 +79,6 @@ impl Geometry {
                     .map(Face::from)
                     .collect();
 
-                assert!(
-                    !faces_collection.is_empty(),
-                    "Empty (faceless) meshes are not supported",
-                );
-
                 let vertices_collection: Vec<_> = vertices.into_iter().collect();
                 let mut normals_collection = Vec::with_capacity(faces_collection.len());
 
@@ -214,11 +210,6 @@ impl Geometry {
         N: IntoIterator<Item = Vector3<f32>>,
     {
         let faces_collection: Vec<_> = faces.into_iter().collect();
-        assert!(
-            !faces_collection.is_empty(),
-            "Empty (faceless) meshes are not supported.",
-        );
-
         let vertices_collection: Vec<_> = vertices.into_iter().collect();
         let normals_collection: Vec<_> = normals.into_iter().collect();
 
@@ -785,7 +776,87 @@ fn remove_orphan_vertices_and_normals(
     (faces_renumbered, vertices_reduced, normals_reduced)
 }
 
-pub fn plane(position: [f32; 3], scale: f32) -> Geometry {
+/// Plane defining euclidean orthogonal unit space origin and orientation.
+///
+/// The plane is endless, has an origin, orientation defined by mutually
+/// perpendicular X and Y direction vectors. Such plane doesn't allow for
+/// distortions or scaling.
+///
+/// The X vector is leading and its direction is kept in the plane unchanged.
+/// The Y vector is only a hint and is being recalculated to be perpendicular to
+/// the leading X vector.
+///
+/// # Panics
+/// Panics if the X and Y vectors are parallel (identical or reverted).
+#[derive(Debug, Clone, Copy, PartialEq)]
+pub struct Plane {
+    pub origin: Point3<f32>,
+    pub x_vector: Vector3<f32>,
+    pub y_vector: Vector3<f32>,
+}
+
+impl Plane {
+    pub fn new(
+        origin: &Point3<f32>,
+        x_vector: &Vector3<f32>,
+        y_vector_hint: &Vector3<f32>,
+    ) -> Plane {
+        let x_vector_normalized = x_vector.normalize();
+        let y_vector_hint_normalized = y_vector_hint.normalize();
+
+        assert!(
+            x_vector_normalized != y_vector_hint_normalized,
+            "The X and Y vectors defining a plane must be different."
+        );
+        assert!(
+            x_vector_normalized != -1.0 * y_vector_hint_normalized,
+            "The X and Y vectors defining a plane can't form a 180 degree angle."
+        );
+
+        // Make sure the Y vector is perpendicular to the leading X vector
+        let plane_normal = x_vector_normalized.cross(&y_vector_hint_normalized);
+        let y_vector_normalized = plane_normal.cross(&x_vector_normalized).normalize();
+
+        Plane {
+            origin: *origin,
+            x_vector: x_vector_normalized,
+            y_vector: y_vector_normalized,
+        }
+    }
+
+    /// The rotation of the X and Y vector around the normal is random.
+    ///
+    /// # Panics
+    /// Panics if the normal vector is a zero vector.
+    pub fn from_origin_and_normal(origin: &Point3<f32>, normal: &Vector3<f32>) -> Plane {
+        assert_ne!(*normal, Vector3::zeros());
+        let lead_vector =
+            if approx::relative_eq!(Vector3::new(1.0, 0.0, 0.0).dot(&normal).abs(), 1.0) {
+                Vector3::new(0.0, 1.0, 0.0)
+            } else {
+                Vector3::new(1.0, 0.0, 0.0)
+            };
+        let y_vector = normal.cross(&lead_vector);
+        let x_vector = normal.cross(&y_vector);
+        Plane::new(origin, &x_vector, &y_vector)
+    }
+
+    pub fn from_three_points(
+        origin: &Point3<f32>,
+        point_on_x: &Point3<f32>,
+        point_on_y: &Point3<f32>,
+    ) -> Plane {
+        let x_vector = point_on_x - origin;
+        let y_vector = point_on_y - origin;
+        Plane::new(origin, &x_vector, &y_vector)
+    }
+
+    pub fn normal(&self) -> Vector3<f32> {
+        self.x_vector.cross(&self.y_vector).normalize()
+    }
+}
+
+pub fn plane_geometry(position: [f32; 3], scale: f32) -> Geometry {
     #[rustfmt::skip]
     let vertex_positions = vec![
         v(-1.0, -1.0,  0.0, position, scale),
@@ -807,7 +878,7 @@ pub fn plane(position: [f32; 3], scale: f32) -> Geometry {
     Geometry::from_triangle_faces_with_vertices_and_normals(faces, vertex_positions, vertex_normals)
 }
 
-pub fn cube_smooth(position: [f32; 3], scale: f32) -> Geometry {
+pub fn cube_smooth_geometry(position: [f32; 3], scale: f32) -> Geometry {
     let vertex_positions = vec![
         // back
         v(-1.0, 1.0, -1.0, position, scale),
@@ -862,7 +933,7 @@ pub fn cube_smooth(position: [f32; 3], scale: f32) -> Geometry {
     Geometry::from_triangle_faces_with_vertices_and_normals(faces, vertex_positions, vertex_normals)
 }
 
-pub fn cube_sharp(position: [f32; 3], scale: f32) -> Geometry {
+pub fn cube_sharp_geometry(position: [f32; 3], scale: f32) -> Geometry {
     let vertex_positions = vec![
         // back
         v(-1.0, 1.0, -1.0, position, scale),
@@ -921,7 +992,12 @@ pub fn cube_sharp(position: [f32; 3], scale: f32) -> Geometry {
 /// # Panics
 /// Panics if number of parallels is less than 2 or number of
 /// meridians is less than 3.
-pub fn uv_sphere(position: [f32; 3], scale: f32, n_parallels: u32, n_meridians: u32) -> Geometry {
+pub fn uv_sphere_geometry(
+    position: [f32; 3],
+    scale: f32,
+    n_parallels: u32,
+    n_meridians: u32,
+) -> Geometry {
     assert!(n_parallels >= 2, "Need at least 2 parallels");
     assert!(n_meridians >= 3, "Need at least 3 meridians");
 
@@ -1065,11 +1141,15 @@ fn n(x: f32, y: f32, z: f32) -> Vector3<f32> {
     Vector3::new(x, y, z)
 }
 
-fn compute_triangle_normal(p1: &Point3<f32>, p2: &Point3<f32>, p3: &Point3<f32>) -> Vector3<f32> {
+pub fn compute_triangle_normal(
+    p1: &Point3<f32>,
+    p2: &Point3<f32>,
+    p3: &Point3<f32>,
+) -> Vector3<f32> {
     let u = p2 - p1;
     let v = p3 - p1;
 
-    Vector3::cross(&u, &v)
+    Vector3::cross(&u, &v).normalize()
 }
 
 #[cfg(test)]
@@ -1119,55 +1199,6 @@ mod tests {
         (faces, vertices, normals)
     }
 
-    #[test]
-    #[should_panic = "Empty (faceless) meshes are not supported"]
-    fn test_geometry_from_triangle_faces_with_vertices_and_computed_normals_empty_geometry() {
-        Geometry::from_triangle_faces_with_vertices_and_computed_normals(
-            vec![],
-            vec![],
-            NormalStrategy::Sharp,
-        );
-    }
-
-    #[test]
-    #[should_panic = "Empty (faceless) meshes are not supported"]
-    fn test_geometry_from_triangle_faces_with_vertices_and_computed_normals_remove_orphans_empty_geometry(
-    ) {
-        Geometry::from_triangle_faces_with_vertices_and_computed_normals_remove_orphans(
-            vec![],
-            vec![],
-            NormalStrategy::Sharp,
-        );
-    }
-
-    #[test]
-    #[should_panic = "Empty (faceless) meshes are not supported"]
-    fn test_geometry_from_triangle_faces_with_vertices_and_normals_empty_geometry() {
-        Geometry::from_triangle_faces_with_vertices_and_normals(vec![], vec![], vec![]);
-    }
-
-    #[test]
-    #[should_panic = "Empty (faceless) meshes are not supported"]
-    fn test_geometry_from_triangle_faces_with_vertices_and_normals_remove_orphans_empty_geometry() {
-        Geometry::from_triangle_faces_with_vertices_and_normals_remove_orphans(
-            vec![],
-            vec![],
-            vec![],
-        );
-    }
-
-    #[test]
-    #[should_panic = "Empty (faceless) meshes are not supported"]
-    fn test_geometry_from_faces_with_vertices_and_normals_empty_geometry() {
-        Geometry::from_faces_with_vertices_and_normals(vec![], vec![], vec![]);
-    }
-
-    #[test]
-    #[should_panic = "Empty (faceless) meshes are not supported"]
-    fn test_geometry_from_faces_with_vertices_and_normals_remove_orphans_empty_geometry() {
-        Geometry::from_faces_with_vertices_and_normals_remove_orphans(vec![], vec![], vec![]);
-    }
-
     #[test]
     fn test_geometry_from_triangle_faces_with_vertices_and_computed_normals() {
         let (faces, vertices) = quad();
@@ -1247,11 +1278,7 @@ mod tests {
             TriangleFace::new(2, 3, 4),
         ];
 
-        Geometry::from_triangle_faces_with_vertices_and_normals(
-            faces.clone(),
-            vertices.clone(),
-            normals.clone(),
-        );
+        Geometry::from_triangle_faces_with_vertices_and_normals(faces, vertices, normals);
     }
 
     #[test]
@@ -1424,11 +1451,8 @@ mod tests {
     fn test_has_no_orphan_vertices_returns_true_if_there_are_some() {
         let (faces, vertices, normals) = quad_with_normals();
 
-        let geometry_without_orphans = Geometry::from_triangle_faces_with_vertices_and_normals(
-            faces.clone(),
-            vertices.clone(),
-            normals.clone(),
-        );
+        let geometry_without_orphans =
+            Geometry::from_triangle_faces_with_vertices_and_normals(faces, vertices, normals);
 
         assert!(geometry_without_orphans.has_no_orphan_vertices());
     }
@@ -1440,9 +1464,9 @@ mod tests {
         let vertices_extended = [&vertices[..], &extra_vertex[..]].concat();
 
         let geometry_with_orphans = Geometry::from_triangle_faces_with_vertices_and_normals(
-            faces.clone(),
-            vertices_extended.clone(),
-            normals.clone(),
+            faces,
+            vertices_extended,
+            normals,
         );
 
         assert!(!geometry_with_orphans.has_no_orphan_vertices());
@@ -1452,11 +1476,8 @@ mod tests {
     fn test_has_no_orphan_normals_returns_true_if_there_are_some() {
         let (faces, vertices, normals) = quad_with_normals();
 
-        let geometry_without_orphans = Geometry::from_triangle_faces_with_vertices_and_normals(
-            faces.clone(),
-            vertices.clone(),
-            normals.clone(),
-        );
+        let geometry_without_orphans =
+            Geometry::from_triangle_faces_with_vertices_and_normals(faces, vertices, normals);
 
         assert!(geometry_without_orphans.has_no_orphan_normals());
     }
@@ -1464,11 +1485,8 @@ mod tests {
     #[test]
     fn test_geometry_unoriented_edges_iter() {
         let (faces, vertices, normals) = quad_with_normals();
-        let geometry = Geometry::from_triangle_faces_with_vertices_and_normals(
-            faces.clone(),
-            vertices.clone(),
-            normals.clone(),
-        );
+        let geometry =
+            Geometry::from_triangle_faces_with_vertices_and_normals(faces, vertices, normals);
         let unoriented_edges_correct = vec![
             UnorientedEdge(OrientedEdge::new(0, 1)),
             UnorientedEdge(OrientedEdge::new(1, 2)),
@@ -1492,11 +1510,8 @@ mod tests {
     #[test]
     fn test_geometry_oriented_edges_iter() {
         let (faces, vertices, normals) = quad_with_normals();
-        let geometry = Geometry::from_triangle_faces_with_vertices_and_normals(
-            faces.clone(),
-            vertices.clone(),
-            normals.clone(),
-        );
+        let geometry =
+            Geometry::from_triangle_faces_with_vertices_and_normals(faces, vertices, normals);
 
         let oriented_edges_correct = vec![
             OrientedEdge::new(0, 1),
@@ -1525,9 +1540,9 @@ mod tests {
         let normals_extended = [&normals[..], &extra_normal[..]].concat();
 
         let geometry_with_orphans = Geometry::from_triangle_faces_with_vertices_and_normals(
-            faces.clone(),
-            vertices.clone(),
-            normals_extended.clone(),
+            faces,
+            vertices,
+            normals_extended,
         );
 
         assert!(!geometry_with_orphans.has_no_orphan_normals());
@@ -1671,4 +1686,93 @@ mod tests {
 
         assert!(geometry.has_no_orphan_vertices());
     }
+
+    #[test]
+    fn test_geometry_compute_triangle_normal_returns_z_vector_for_horizontal_triangle() {
+        let faces = vec![(0, 1, 2)];
+        let vertices = vec![
+            Point3::new(0.0, 1.0, 0.0),
+            Point3::new(-0.866025, -0.5, 0.0),
+            Point3::new(0.866025, -0.5, 0.0),
+        ];
+        let geometry = Geometry::from_triangle_faces_with_vertices_and_computed_normals(
+            faces,
+            vertices,
+            NormalStrategy::Sharp,
+        );
+
+        let normal_correct = Vector3::new(0.0, 0.0, 1.0);
+
+        let Face::Triangle(t_f) = geometry.faces()[0];
+        let normal_calculated = compute_triangle_normal(
+            &geometry.vertices()[cast_usize(t_f.vertices.0)],
+            &geometry.vertices()[cast_usize(t_f.vertices.1)],
+            &geometry.vertices()[cast_usize(t_f.vertices.2)],
+        );
+
+        assert_eq!(normal_correct, normal_calculated);
+    }
+
+    #[test]
+    fn test_geometry_compute_triangle_normal_returns_x_vector_for_vertical_triangle() {
+        let faces = vec![(0, 1, 2)];
+        let vertices = vec![
+            Point3::new(0.0, 1.0, 0.0),
+            Point3::new(0.0, -0.5, 0.866025),
+            Point3::new(0.0, -0.5, -0.866025),
+        ];
+        let geometry = Geometry::from_triangle_faces_with_vertices_and_computed_normals(
+            faces,
+            vertices,
+            NormalStrategy::Sharp,
+        );
+
+        let normal_correct = Vector3::new(1.0, 0.0, 0.0);
+
+        let Face::Triangle(t_f) = geometry.faces()[0];
+        let normal_calculated = compute_triangle_normal(
+            &geometry.vertices()[cast_usize(t_f.vertices.0)],
+            &geometry.vertices()[cast_usize(t_f.vertices.1)],
+            &geometry.vertices()[cast_usize(t_f.vertices.2)],
+        );
+
+        assert_eq!(normal_correct, normal_calculated);
+    }
+
+    #[test]
+    fn test_geometry_compute_triangle_normal_returns_vector_for_arbitrary_triangle() {
+        let faces = vec![(0, 1, 2)];
+        let vertices = vec![
+            Point3::new(0.268023, 0.8302, 0.392469),
+            Point3::new(-0.870844, -0.462665, 0.215034),
+            Point3::new(0.334798, -0.197734, -0.999972),
+        ];
+        let geometry = Geometry::from_triangle_faces_with_vertices_and_computed_normals(
+            faces,
+            vertices,
+            NormalStrategy::Sharp,
+        );
+
+        let normal_correct = Vector3::new(0.62270945, -0.614937, 0.48382375);
+
+        let Face::Triangle(t_f) = geometry.faces()[0];
+        let normal_calculated = compute_triangle_normal(
+            &geometry.vertices()[cast_usize(t_f.vertices.0)],
+            &geometry.vertices()[cast_usize(t_f.vertices.1)],
+            &geometry.vertices()[cast_usize(t_f.vertices.2)],
+        );
+
+        assert_eq!(normal_correct, normal_calculated);
+    }
+
+    #[test]
+    fn test_geometry_plane_new_calculate_perpendicular_y() {
+        let test_plane = Plane::new(
+            &Point3::new(0.0, 0.0, 0.0),
+            &Vector3::new(1.0, 0.0, 0.0),
+            &Vector3::new(1.0, 1.0, 0.0),
+        );
+
+        assert_eq!(test_plane.y_vector, Vector3::new(0.0, 1.0, 0.0));
+    }
 }
diff --git a/src/importer.rs b/src/importer.rs
index 08a1882..50c3aa8 100644
--- a/src/importer.rs
+++ b/src/importer.rs
@@ -357,15 +357,11 @@ mod tests {
 
     use super::*;
 
-    fn create_tobj_model(
-        face_vertex_indices: Vec<u32>,
-        positions: Vec<f32>,
-        normals: Vec<f32>,
-    ) -> tobj::Model {
+    fn create_tobj_model(indices: Vec<u32>, positions: Vec<f32>, normals: Vec<f32>) -> tobj::Model {
         tobj::Model {
             name: String::from("Test model"),
             mesh: tobj::Mesh {
-                indices: face_vertex_indices,
+                indices,
                 positions,
                 normals,
                 texcoords: vec![],
@@ -374,14 +370,6 @@ mod tests {
         }
     }
 
-    fn triangle() -> tobj::Model {
-        create_tobj_model(
-            vec![0, 1, 2],
-            vec![6.0, 5.0, 4.0, 3.0, 2.0, 1.0, 0.0, 1.0, 2.0],
-            vec![0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0],
-        )
-    }
-
     #[test]
     fn test_tobj_to_internal_returns_correct_representation_for_single_model() {
         let tobj_model = create_tobj_model(
@@ -525,7 +513,7 @@ mod tests {
             checksum,
             last_modified: SystemTime::now(),
         };
-        let models = tobj_to_internal(vec![triangle()]);
+        let models = tobj_to_internal(vec![create_tobj_model(vec![], vec![], vec![])]);
 
         cache.set(path.clone(), metadata, &models);
 
@@ -548,14 +536,18 @@ mod tests {
             checksum,
             last_modified: SystemTime::now(),
         };
-        let models = tobj_to_internal(vec![triangle()]);
+        let models = tobj_to_internal(vec![create_tobj_model(
+            vec![0],
+            vec![4.0, 5.0, 6.0],
+            vec![1.0, 1.0, 1.0],
+        )]);
 
         cache.set(path.clone(), metadata, &models);
 
         let new_models = tobj_to_internal(vec![create_tobj_model(
-            vec![0, 1, 2],
-            vec![6.0, 5.0, 4.0, 3.0, 2.0, 1.0, 0.0, 1.0, 2.0],
-            vec![0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0],
+            vec![0],
+            vec![4.0, 5.0, 6.0],
+            vec![0.0, 0.0, 0.0],
         )]);
 
         cache.set(path.clone(), metadata, &new_models);
@@ -579,7 +571,7 @@ mod tests {
             checksum: 1u32,
             last_modified: now,
         };
-        let models = tobj_to_internal(vec![triangle()]);
+        let models = tobj_to_internal(vec![create_tobj_model(vec![], vec![], vec![])]);
         cache.set(path.clone(), metadata, &models);
 
         let loaded_models = cache.get_if_not_modified(&path, now);
@@ -596,7 +588,7 @@ mod tests {
             checksum: 1u32,
             last_modified: now,
         };
-        let models = tobj_to_internal(vec![triangle()]);
+        let models = tobj_to_internal(vec![create_tobj_model(vec![], vec![], vec![])]);
         cache.set(path.clone(), metadata, &models);
 
         let loaded_models = cache.get_if_not_modified(
@@ -617,7 +609,7 @@ mod tests {
             checksum,
             last_modified: SystemTime::now(),
         };
-        let models = tobj_to_internal(vec![triangle()]);
+        let models = tobj_to_internal(vec![create_tobj_model(vec![], vec![], vec![])]);
         cache.set(path.clone(), metadata, &models);
 
         let loaded_models = cache.get_by_checksum(checksum);
@@ -634,7 +626,7 @@ mod tests {
             checksum,
             last_modified: SystemTime::now(),
         };
-        let models = tobj_to_internal(vec![triangle()]);
+        let models = tobj_to_internal(vec![create_tobj_model(vec![], vec![], vec![])]);
         cache.set(path.clone(), metadata, &models);
 
         let loaded_models = cache.get_by_checksum(checksum + 1);
diff --git a/src/interpreter/func.rs b/src/interpreter/func.rs
index 42054ba..883439f 100644
--- a/src/interpreter/func.rs
+++ b/src/interpreter/func.rs
@@ -1,6 +1,6 @@
 use bitflags::bitflags;
 
-use super::{FuncError, Ty, Value};
+use super::{Ty, Value};
 
 bitflags! {
     /// Information about the function behaviour.
@@ -71,5 +71,5 @@ pub trait Func {
     ///
     /// [`param_info`]: trait.Func.html#tymethod.param_info
     /// [`return_ty`]: trait.Func.html#tymethod.return_ty
-    fn call(&self, args: &[Value]) -> Result<Value, FuncError>;
+    fn call(&self, args: &[Value]) -> Value;
 }
diff --git a/src/interpreter/mod.rs b/src/interpreter/mod.rs
index 8b131bb..bd6429d 100644
--- a/src/interpreter/mod.rs
+++ b/src/interpreter/mod.rs
@@ -2,7 +2,6 @@ use std::collections::hash_map::{Entry, HashMap};
 use std::collections::HashSet;
 use std::error;
 use std::fmt;
-use std::ptr;
 
 pub use self::ast::{FuncIdent, VarIdent};
 pub use self::func::{Func, FuncFlags, ParamInfo};
@@ -56,34 +55,6 @@ impl fmt::Display for TypecheckError {
 
 impl error::Error for TypecheckError {}
 
-/// A dynamic func error.
-#[derive(Debug)]
-pub struct FuncError(Box<dyn error::Error + Send>);
-
-impl FuncError {
-    pub fn new<E: error::Error + Send + 'static>(error: E) -> Self {
-        Self(Box::new(error))
-    }
-}
-
-impl PartialEq for FuncError {
-    /// Compares whether two func errors are exactly the same instance.
-    fn eq(&self, other: &FuncError) -> bool {
-        // FIXME: @Correctness Can we somehow make this equality deep
-        // so we don't have to do downcasting shenanigans when
-        // comparing?
-        ptr::eq(&self.0, &other.0)
-    }
-}
-
-impl fmt::Display for FuncError {
-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-        write!(f, "{}", self.0)
-    }
-}
-
-impl error::Error for FuncError {}
-
 /// A runtime error.
 #[derive(Debug, PartialEq)]
 pub enum RuntimeError {
@@ -106,11 +77,6 @@ pub enum RuntimeError {
         ty_expected: Ty,
         ty_provided: Ty,
     },
-    Func {
-        stmt_index: usize,
-        call: ast::CallExpr,
-        func_error: FuncError,
-    },
 }
 
 impl fmt::Display for RuntimeError {
@@ -157,17 +123,6 @@ impl fmt::Display for RuntimeError {
                 ty_provided,
                 stmt_index,
             ),
-            RuntimeError::Func {
-                stmt_index,
-                call,
-                func_error,
-            } => write!(
-                f,
-                "Function {} errored with \"{}\" on stmt {}",
-                call.ident(),
-                func_error,
-                stmt_index,
-            ),
         }
     }
 }
@@ -393,7 +348,7 @@ impl Interpreter {
     }
 
     /// Interprets the whole currently set program and returns the
-    /// used/unused values after the last statment.
+    /// used/unused values after the last statement.
     ///
     /// # Panics
     /// Panics if the currently set program is empty.
@@ -421,7 +376,7 @@ impl Interpreter {
         let max_index = self.prog.stmts().len() - 1;
         assert!(
             max_index >= index,
-            "Can not execute past the program lenght",
+            "Can not execute past the program length",
         );
 
         self.resolve()?;
@@ -742,29 +697,20 @@ fn eval_call_expr(
         }
     }
 
-    let result = func.call(&args);
-    match result {
-        Ok(value) => {
-            let return_ty = func.return_ty();
-            let value_ty = value.ty();
-
-            if return_ty != value_ty {
-                return Err(RuntimeError::ReturnTyMismatch {
-                    stmt_index,
-                    call: call.clone(),
-                    ty_expected: return_ty,
-                    ty_provided: value_ty,
-                });
-            }
+    let value = func.call(&args);
 
-            Ok(value)
-        }
-        Err(func_error) => Err(RuntimeError::Func {
+    let return_ty = func.return_ty();
+    let value_ty = value.ty();
+    if return_ty != value_ty {
+        return Err(RuntimeError::ReturnTyMismatch {
             stmt_index,
             call: call.clone(),
-            func_error,
-        }),
+            ty_expected: return_ty,
+            ty_provided: value_ty,
+        });
     }
+
+    Ok(value)
 }
 
 #[cfg(test)]
@@ -774,20 +720,14 @@ mod tests {
 
     use super::*;
 
-    struct TestFunc<F>
-    where
-        F: Fn(&[Value]) -> Result<Value, FuncError>,
-    {
+    struct TestFunc<F: Fn(&[Value]) -> Value> {
         func: F,
         flags: FuncFlags,
         param_info: Vec<ParamInfo>,
         return_ty: Ty,
     }
 
-    impl<F> TestFunc<F>
-    where
-        F: Fn(&[Value]) -> Result<Value, FuncError>,
-    {
+    impl<F: Fn(&[Value]) -> Value> TestFunc<F> {
         pub fn new(func: F, flags: FuncFlags, param_info: Vec<ParamInfo>, return_ty: Ty) -> Self {
             Self {
                 flags,
@@ -798,10 +738,7 @@ mod tests {
         }
     }
 
-    impl<F> Func for TestFunc<F>
-    where
-        F: Fn(&[Value]) -> Result<Value, FuncError>,
-    {
+    impl<F: Fn(&[Value]) -> Value> Func for TestFunc<F> {
         fn flags(&self) -> FuncFlags {
             self.flags
         }
@@ -814,8 +751,8 @@ mod tests {
             self.return_ty
         }
 
-        fn call(&self, values: &[Value]) -> Result<Value, FuncError> {
-            ((self.func)(values))
+        fn call(&self, values: &[Value]) -> Value {
+            (self.func)(values)
         }
     }
 
@@ -847,7 +784,7 @@ mod tests {
         let (func_id, func) = (
             FuncIdent(0),
             TestFunc::new(
-                |_| Ok(Value::Boolean(true)),
+                |_| Value::Boolean(true),
                 FuncFlags::PURE,
                 vec![],
                 Ty::Boolean,
@@ -874,7 +811,7 @@ mod tests {
         let (func_id, func) = (
             FuncIdent(0),
             TestFunc::new(
-                |values| Ok(Value::Boolean(values[0].unwrap_boolean())),
+                |values| Value::Boolean(values[0].unwrap_boolean()),
                 FuncFlags::PURE,
                 vec![ParamInfo {
                     ty: Ty::Boolean,
@@ -904,7 +841,7 @@ mod tests {
         let (func_id, func) = (
             FuncIdent(0),
             TestFunc::new(
-                |_| Ok(Value::Boolean(true)),
+                |_| Value::Boolean(true),
                 FuncFlags::empty(),
                 vec![],
                 Ty::Boolean,
@@ -931,7 +868,7 @@ mod tests {
         let (func_id, func) = (
             FuncIdent(0),
             TestFunc::new(
-                |values| Ok(Value::Boolean(values[0].unwrap_boolean())),
+                |values| Value::Boolean(values[0].unwrap_boolean()),
                 FuncFlags::empty(),
                 vec![ParamInfo {
                     ty: Ty::Boolean,
@@ -961,7 +898,7 @@ mod tests {
         let (func_id1, func1) = (
             FuncIdent(0),
             TestFunc::new(
-                |_| Ok(Value::Boolean(true)),
+                |_| Value::Boolean(true),
                 FuncFlags::PURE,
                 vec![],
                 Ty::Boolean,
@@ -970,7 +907,7 @@ mod tests {
         let (func_id2, func2) = (
             FuncIdent(1),
             TestFunc::new(
-                |values| Ok(Value::Boolean(values[0].unwrap_boolean())),
+                |values| Value::Boolean(values[0].unwrap_boolean()),
                 FuncFlags::PURE,
                 vec![ParamInfo {
                     ty: Ty::Boolean,
@@ -1010,7 +947,7 @@ mod tests {
         let (func_id1, func1) = (
             FuncIdent(0),
             TestFunc::new(
-                |_| Ok(Value::Boolean(true)),
+                |_| Value::Boolean(true),
                 FuncFlags::empty(),
                 vec![],
                 Ty::Boolean,
@@ -1019,7 +956,7 @@ mod tests {
         let (func_id2, func2) = (
             FuncIdent(1),
             TestFunc::new(
-                |values| Ok(Value::Boolean(values[0].unwrap_boolean())),
+                |values| Value::Boolean(values[0].unwrap_boolean()),
                 FuncFlags::empty(),
                 vec![ParamInfo {
                     ty: Ty::Boolean,
@@ -1079,12 +1016,12 @@ mod tests {
     }
 
     #[test]
-    #[should_panic(expected = "Can not execute past the program lenght")]
+    #[should_panic(expected = "Can not execute past the program length")]
     fn test_interpreter_interpret_up_until_invalid_index() {
         let (func_id, func) = (
             FuncIdent(0),
             TestFunc::new(
-                |_| Ok(Value::Boolean(true)),
+                |_| Value::Boolean(true),
                 FuncFlags::PURE,
                 vec![],
                 Ty::Boolean,
@@ -1110,7 +1047,7 @@ mod tests {
         let (func_id, func) = (
             FuncIdent(0),
             TestFunc::new(
-                |_| Ok(Value::Boolean(true)),
+                |_| Value::Boolean(true),
                 FuncFlags::PURE,
                 vec![],
                 Ty::Boolean,
@@ -1150,7 +1087,7 @@ mod tests {
             TestFunc::new(
                 move |values| {
                     c.inc();
-                    Ok(Value::Boolean(values[0].unwrap_boolean()))
+                    Value::Boolean(values[0].unwrap_boolean())
                 },
                 FuncFlags::PURE,
                 vec![ParamInfo {
@@ -1190,7 +1127,7 @@ mod tests {
             TestFunc::new(
                 move |values| {
                     c.inc();
-                    Ok(Value::Boolean(values[0].unwrap_boolean()))
+                    Value::Boolean(values[0].unwrap_boolean())
                 },
                 FuncFlags::empty(),
                 vec![ParamInfo {
@@ -1233,9 +1170,9 @@ mod tests {
                     let value = values[0].unwrap_boolean();
                     let negate = values[1].unwrap_boolean();
                     if negate {
-                        Ok(Value::Boolean(!value))
+                        Value::Boolean(!value)
                     } else {
-                        Ok(Value::Boolean(value))
+                        Value::Boolean(value)
                     }
                 },
                 FuncFlags::PURE,
@@ -1308,9 +1245,9 @@ mod tests {
                     let value = values[0].unwrap_boolean();
                     let negate = values[1].unwrap_boolean();
                     if negate {
-                        Ok(Value::Boolean(!value))
+                        Value::Boolean(!value)
                     } else {
-                        Ok(Value::Boolean(value))
+                        Value::Boolean(value)
                     }
                 },
                 FuncFlags::PURE,
@@ -1336,9 +1273,9 @@ mod tests {
                     let value = values[0].unwrap_boolean();
                     let negate = values[1].unwrap_boolean();
                     if negate {
-                        Ok(Value::Boolean(!value))
+                        Value::Boolean(!value)
                     } else {
-                        Ok(Value::Boolean(value))
+                        Value::Boolean(value)
                     }
                 },
                 FuncFlags::PURE,
@@ -1411,7 +1348,7 @@ mod tests {
             TestFunc::new(
                 move |_| {
                     c1.inc();
-                    Ok(Value::Boolean(true))
+                    Value::Boolean(true)
                 },
                 FuncFlags::empty(),
                 vec![],
@@ -1424,7 +1361,7 @@ mod tests {
             TestFunc::new(
                 move |values| {
                     c2.inc();
-                    Ok(Value::Boolean(values[0].unwrap_boolean()))
+                    Value::Boolean(values[0].unwrap_boolean())
                 },
                 FuncFlags::PURE,
                 vec![ParamInfo {
@@ -1475,7 +1412,7 @@ mod tests {
         let (func_id, func) = (
             FuncIdent(0),
             TestFunc::new(
-                |_| Ok(Value::Boolean(true)),
+                |_| Value::Boolean(true),
                 FuncFlags::PURE,
                 vec![],
                 Ty::Boolean,
@@ -1514,7 +1451,7 @@ mod tests {
         let (func_id, func) = (
             FuncIdent(0),
             TestFunc::new(
-                |values| Ok(Value::Boolean(values[0].unwrap_boolean())),
+                |values| Value::Boolean(values[0].unwrap_boolean()),
                 FuncFlags::PURE,
                 vec![ParamInfo {
                     ty: Ty::Boolean,
@@ -1553,7 +1490,7 @@ mod tests {
         let (func_id, func) = (
             FuncIdent(0),
             TestFunc::new(
-                |values| Ok(Value::Boolean(values[0].unwrap_boolean())),
+                |values| Value::Boolean(values[0].unwrap_boolean()),
                 FuncFlags::PURE,
                 vec![ParamInfo {
                     ty: Ty::Boolean,
@@ -1594,7 +1531,7 @@ mod tests {
         let (func_id, func) = (
             FuncIdent(0),
             TestFunc::new(
-                |values| Ok(Value::Boolean(values[0].unwrap_boolean())),
+                |values| Value::Boolean(values[0].unwrap_boolean()),
                 FuncFlags::PURE,
                 vec![ParamInfo {
                     ty: Ty::Boolean,
@@ -1666,7 +1603,7 @@ mod tests {
         let (func_id, func) = (
             FuncIdent(0),
             TestFunc::new(
-                |values| Ok(Value::Float(values[0].unwrap_float() + 1.0)),
+                |values| Value::Float(values[0].unwrap_float() + 1.0),
                 FuncFlags::PURE,
                 vec![ParamInfo {
                     ty: Ty::Float,
@@ -1711,7 +1648,7 @@ mod tests {
         let (func_id, func) = (
             FuncIdent(0),
             TestFunc::new(
-                |values| Ok(Value::Float(values[0].unwrap_float() + 1.0)),
+                |values| Value::Float(values[0].unwrap_float() + 1.0),
                 FuncFlags::PURE,
                 vec![ParamInfo {
                     ty: Ty::Float,
@@ -1751,7 +1688,7 @@ mod tests {
         let (func_id, func) = (
             FuncIdent(0),
             TestFunc::new(
-                |values| Ok(Value::Float(values[0].get_float().unwrap_or(1.0))),
+                |values| Value::Float(values[0].get_float().unwrap_or(1.0)),
                 FuncFlags::PURE,
                 vec![ParamInfo {
                     ty: Ty::Float,
@@ -1782,7 +1719,7 @@ mod tests {
         let (func_id, func) = (
             FuncIdent(0),
             TestFunc::new(
-                |values| Ok(Value::Float(values[0].get_float().unwrap_or(1.0))),
+                |values| Value::Float(values[0].get_float().unwrap_or(1.0)),
                 FuncFlags::PURE,
                 vec![ParamInfo {
                     ty: Ty::Float,
@@ -1821,7 +1758,7 @@ mod tests {
     fn test_interpreter_interpret_single_func_dynamic_return_ty_error() {
         let (func_id, func) = (
             FuncIdent(0),
-            TestFunc::new(|_| Ok(Value::Int(-1)), FuncFlags::PURE, vec![], Ty::Float),
+            TestFunc::new(|_| Value::Int(-1), FuncFlags::PURE, vec![], Ty::Float),
         );
 
         let call = ast::CallExpr::new(func_id, vec![]);
@@ -1848,64 +1785,6 @@ mod tests {
         );
     }
 
-    // Func runtime erorrs tests
-
-    #[test]
-    fn test_interpreter_interpret_single_func_runtime_error() {
-        #[derive(Debug, PartialEq)]
-        struct ConcreteFuncError(i32);
-
-        impl fmt::Display for ConcreteFuncError {
-            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-                write!(f, "Concrete func error with code {}", self.0)
-            }
-        }
-
-        impl error::Error for ConcreteFuncError {}
-
-        let (func_id, func) = (
-            FuncIdent(0),
-            TestFunc::new(
-                |_| Err(FuncError::new(ConcreteFuncError(42))),
-                FuncFlags::empty(),
-                vec![],
-                Ty::Boolean,
-            ),
-        );
-
-        let call = ast::CallExpr::new(func_id, vec![]);
-        let prog = ast::Prog::new(vec![ast::Stmt::VarDecl(ast::VarDeclStmt::new(
-            VarIdent(0),
-            call.clone(),
-        ))]);
-
-        let mut funcs: HashMap<FuncIdent, Box<dyn Func>> = HashMap::new();
-        funcs.insert(func_id, Box::new(func));
-
-        let mut interpreter = Interpreter::new(funcs);
-        interpreter.set_prog(prog);
-
-        let err = interpreter.interpret().unwrap_err();
-
-        match err {
-            InterpretError::Runtime(RuntimeError::Func {
-                stmt_index: runtime_error_stmt_index,
-                call: runtime_error_call,
-                func_error: runtime_error_func_error,
-            }) => {
-                assert_eq!(runtime_error_stmt_index, 0);
-                assert_eq!(runtime_error_call, call);
-
-                let concrete_error = runtime_error_func_error
-                    .0
-                    .downcast_ref::<ConcreteFuncError>()
-                    .unwrap();
-                assert_eq!(concrete_error, &ConcreteFuncError(42));
-            }
-            _ => panic!(),
-        }
-    }
-
     // ValueSet tests
 
     #[test]
@@ -1913,7 +1792,7 @@ mod tests {
         let (func_id, func) = (
             FuncIdent(0),
             TestFunc::new(
-                |values| Ok(Value::Float(values[0].unwrap_float() * 2.0)),
+                |values| Value::Float(values[0].unwrap_float() * 2.0),
                 FuncFlags::PURE,
                 vec![ParamInfo {
                     ty: Ty::Float,
diff --git a/src/interpreter_funcs.rs b/src/interpreter_funcs.rs
index 0a05325..a1fd1d7 100644
--- a/src/interpreter_funcs.rs
+++ b/src/interpreter_funcs.rs
@@ -1,45 +1,18 @@
 use std::cmp;
 use std::collections::HashMap;
-use std::error;
-use std::fmt;
 use std::sync::Arc;
 
 use nalgebra::base::Vector3;
 
 use crate::convert::cast_u32;
 use crate::geometry;
-use crate::interpreter::{Func, FuncError, FuncFlags, FuncIdent, ParamInfo, Ty, Value};
+use crate::interpreter::{Func, FuncFlags, FuncIdent, ParamInfo, Ty, Value};
 use crate::mesh_smoothing;
 use crate::mesh_tools;
 use crate::mesh_topology_analysis;
 use crate::operations::shrink_wrap::{self, ShrinkWrapParams};
 use crate::operations::transform;
 
-#[derive(Debug, PartialEq)]
-pub enum FuncCreateUvSphereError {
-    TooFewParallels { parallels_provided: u32 },
-    TooFewMeridians { meridians_provided: u32 },
-}
-
-impl fmt::Display for FuncCreateUvSphereError {
-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-        match self {
-            FuncCreateUvSphereError::TooFewParallels { parallels_provided } => write!(
-                f,
-                "Create UV Sphere requires at least 2 parallels, but only {} provided",
-                parallels_provided,
-            ),
-            FuncCreateUvSphereError::TooFewMeridians { meridians_provided } => write!(
-                f,
-                "Create UV Sphere requires at least 3 meridians, but only {} provided",
-                meridians_provided,
-            ),
-        }
-    }
-}
-
-impl error::Error for FuncCreateUvSphereError {}
-
 pub struct FuncImplCreateUvSphere;
 impl Func for FuncImplCreateUvSphere {
     fn flags(&self) -> FuncFlags {
@@ -67,28 +40,14 @@ impl Func for FuncImplCreateUvSphere {
         Ty::Geometry
     }
 
-    fn call(&self, args: &[Value]) -> Result<Value, FuncError> {
+    fn call(&self, args: &[Value]) -> Value {
         let scale = args[0].unwrap_float();
         let n_parallels = args[1].unwrap_uint();
         let n_meridians = args[2].unwrap_uint();
 
-        const MIN_PARALLELS: u32 = 2;
-        const MIN_MERIDIANS: u32 = 3;
-
-        if n_parallels < MIN_PARALLELS {
-            return Err(FuncError::new(FuncCreateUvSphereError::TooFewParallels {
-                parallels_provided: n_parallels,
-            }));
-        }
-        if n_meridians < MIN_MERIDIANS {
-            return Err(FuncError::new(FuncCreateUvSphereError::TooFewMeridians {
-                meridians_provided: n_meridians,
-            }));
-        }
-
-        let value = geometry::uv_sphere([0.0, 0.0, 0.0], scale, n_parallels, n_meridians);
+        let value = geometry::uv_sphere_geometry([0.0, 0.0, 0.0], scale, n_parallels, n_meridians);
 
-        Ok(Value::Geometry(Arc::new(value)))
+        Value::Geometry(Arc::new(value))
     }
 }
 
@@ -115,13 +74,13 @@ impl Func for FuncImplShrinkWrap {
         Ty::Geometry
     }
 
-    fn call(&self, args: &[Value]) -> Result<Value, FuncError> {
+    fn call(&self, args: &[Value]) -> Value {
         let value = shrink_wrap::shrink_wrap(ShrinkWrapParams {
             geometry: args[0].unwrap_geometry(),
             sphere_density: cast_u32(args[1].unwrap_uint()),
         });
 
-        Ok(Value::Geometry(Arc::new(value)))
+        Value::Geometry(Arc::new(value))
     }
 }
 
@@ -156,7 +115,7 @@ impl Func for FuncImplTransform {
         Ty::Geometry
     }
 
-    fn call(&self, args: &[Value]) -> Result<Value, FuncError> {
+    fn call(&self, args: &[Value]) -> Value {
         let geometry = args[0].unwrap_geometry();
 
         let translate = args[1].get_float3().map(Vector3::from);
@@ -178,7 +137,7 @@ impl Func for FuncImplTransform {
             },
         );
 
-        Ok(Value::Geometry(Arc::new(value)))
+        Value::Geometry(Arc::new(value))
     }
 }
 
@@ -204,7 +163,7 @@ impl Func for FuncImplLaplacianSmoothing {
         Ty::Geometry
     }
 
-    fn call(&self, args: &[Value]) -> Result<Value, FuncError> {
+    fn call(&self, args: &[Value]) -> Value {
         let geometry = args[0].unwrap_geometry();
         let iterations = args[1].unwrap_uint();
         let vertex_to_vertex_topology = mesh_topology_analysis::vertex_to_vertex_topology(geometry);
@@ -217,7 +176,7 @@ impl Func for FuncImplLaplacianSmoothing {
             false,
         );
 
-        Ok(Value::Geometry(Arc::new(g)))
+        Value::Geometry(Arc::new(g))
     }
 }
 
@@ -234,7 +193,7 @@ impl Func for FuncImplSeparateIsolatedMeshes {
         Ty::Geometry
     }
 
-    fn call(&self, args: &[Value]) -> Result<Value, FuncError> {
+    fn call(&self, args: &[Value]) -> Value {
         let geometry = args[0].unwrap_geometry();
 
         let values = mesh_tools::separate_isolated_meshes(geometry);
@@ -245,7 +204,7 @@ impl Func for FuncImplSeparateIsolatedMeshes {
             .next()
             .expect("Need at least one geometry");
 
-        Ok(Value::Geometry(Arc::new(first_value)))
+        Value::Geometry(Arc::new(first_value))
     }
 }
 
@@ -271,13 +230,13 @@ impl Func for FuncImplJoinMeshes {
         Ty::Geometry
     }
 
-    fn call(&self, args: &[Value]) -> Result<Value, FuncError> {
+    fn call(&self, args: &[Value]) -> Value {
         let first_geometry = args[0].unwrap_geometry();
         let second_geometry = args[1].unwrap_geometry();
 
         let value = mesh_tools::join_meshes(first_geometry, second_geometry);
 
-        Ok(Value::Geometry(Arc::new(value)))
+        Value::Geometry(Arc::new(value))
     }
 }
 
@@ -300,13 +259,13 @@ impl Func for FuncImplWeld {
         Ty::Geometry
     }
 
-    fn call(&self, args: &[Value]) -> Result<Value, FuncError> {
+    fn call(&self, args: &[Value]) -> Value {
         let geometry = args[0].unwrap_geometry();
         let tolerance = args[1].unwrap_float();
 
         let value = mesh_tools::weld(geometry, tolerance);
 
-        Ok(Value::Geometry(Arc::new(value)))
+        Value::Geometry(Arc::new(value))
     }
 }
 
@@ -333,7 +292,7 @@ impl Func for FuncImplLoopSubdivision {
         Ty::Geometry
     }
 
-    fn call(&self, args: &[Value]) -> Result<Value, FuncError> {
+    fn call(&self, args: &[Value]) -> Value {
         // FIXME: add the max value to the param info so that that the
         // gui doesn't mislead
         const MAX_ITERATIONS: u32 = 3;
@@ -342,7 +301,7 @@ impl Func for FuncImplLoopSubdivision {
         let iterations = cmp::min(args[1].unwrap_uint(), MAX_ITERATIONS);
 
         if iterations == 0 {
-            return Ok(Value::Geometry(geometry));
+            return Value::Geometry(geometry);
         }
 
         let mut v2v_topology = mesh_topology_analysis::vertex_to_vertex_topology(&geometry);
@@ -357,7 +316,7 @@ impl Func for FuncImplLoopSubdivision {
                 mesh_smoothing::loop_subdivision(&current_geometry, &v2v_topology, &f2f_topology);
         }
 
-        Ok(Value::Geometry(Arc::new(current_geometry)))
+        Value::Geometry(Arc::new(current_geometry))
     }
 }
 
@@ -384,13 +343,13 @@ impl Func for FuncImplCreatePlane {
         Ty::Geometry
     }
 
-    fn call(&self, values: &[Value]) -> Result<Value, FuncError> {
+    fn call(&self, values: &[Value]) -> Value {
         let position = values[0].get_float3().unwrap_or([0.0; 3]);
         let scale = values[1].get_float().unwrap_or(1.0);
 
-        let value = geometry::plane(position, scale);
+        let value = geometry::plane_geometry(position, scale);
 
-        Ok(Value::Geometry(Arc::new(value)))
+        Value::Geometry(Arc::new(value))
     }
 }
 
diff --git a/src/lib.rs b/src/lib.rs
index d141bfe..5ff017d 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -31,8 +31,10 @@ mod mesh_analysis;
 mod mesh_smoothing;
 mod mesh_tools;
 mod mesh_topology_analysis;
+mod plane_tools;
 mod platform;
 mod ui;
+mod vertex_tools;
 
 const CAMERA_INTERPOLATION_DURATION: Duration = Duration::from_millis(1000);
 
diff --git a/src/mesh_analysis.rs b/src/mesh_analysis.rs
index 3f1ef5e..d397bb1 100644
--- a/src/mesh_analysis.rs
+++ b/src/mesh_analysis.rs
@@ -798,7 +798,7 @@ mod tests {
 
     #[test]
     fn test_mesh_analysis_is_mesh_orientable_returns_true_watertight_mesh() {
-        let geometry = geometry::cube_sharp([0.0, 0.0, 0.0], 1.0);
+        let geometry = geometry::cube_sharp_geometry([0.0, 0.0, 0.0], 1.0);
         let oriented_edges: Vec<OrientedEdge> = geometry.oriented_edges_iter().collect();
         let edge_sharing_map = edge_analysis::edge_sharing(&oriented_edges);
 
@@ -831,7 +831,7 @@ mod tests {
 
     #[test]
     fn test_mesh_analysis_is_mesh_watertight_returns_true_for_watertight_mesh() {
-        let geometry = geometry::cube_sharp([0.0, 0.0, 0.0], 1.0);
+        let geometry = geometry::cube_sharp_geometry([0.0, 0.0, 0.0], 1.0);
         let oriented_edges: Vec<OrientedEdge> = geometry.oriented_edges_iter().collect();
         let edge_sharing_map = edge_analysis::edge_sharing(&oriented_edges);
 
@@ -855,7 +855,7 @@ mod tests {
 
     #[test]
     fn test_geometry_triangulated_mesh_genus_box_should_be_0() {
-        let geometry = geometry::cube_sharp([0.0, 0.0, 0.0], 1.0);
+        let geometry = geometry::cube_sharp_geometry([0.0, 0.0, 0.0], 1.0);
         assert!(geometry.is_triangulated());
 
         let edges: HashSet<UnorientedEdge> = geometry.unoriented_edges_iter().collect();
@@ -960,7 +960,7 @@ mod tests {
 
     #[test]
     fn test_border_edge_loops_returns_one_for_cube() {
-        let geometry = geometry::cube_sharp([0.0, 0.0, 0.0], 1.0);
+        let geometry = geometry::cube_sharp_geometry([0.0, 0.0, 0.0], 1.0);
 
         let oriented_edges: Vec<OrientedEdge> = geometry.oriented_edges_iter().collect();
         let edge_sharing_map = edge_analysis::edge_sharing(&oriented_edges);
diff --git a/src/mesh_smoothing.rs b/src/mesh_smoothing.rs
index f1347e2..0146dcd 100644
--- a/src/mesh_smoothing.rs
+++ b/src/mesh_smoothing.rs
@@ -778,8 +778,8 @@ mod tests {
     }
 
     #[test]
-    fn test_loop_subdivision_snapshot_uv_sphere() {
-        let geometry = geometry::uv_sphere([0.0; 3], 1.0, 2, 3);
+    fn test_loop_subdivision_snapshot_uv_sphere_geometry() {
+        let geometry = geometry::uv_sphere_geometry([0.0; 3], 1.0, 2, 3);
         let v2v = mesh_topology_analysis::vertex_to_vertex_topology(&geometry);
         let f2f = mesh_topology_analysis::face_to_face_topology(&geometry);
 
@@ -792,8 +792,8 @@ mod tests {
     }
 
     #[test]
-    fn test_loop_subdivision_snapshot_cube_sharp() {
-        let geometry = geometry::cube_sharp([0.0; 3], 1.0);
+    fn test_loop_subdivision_snapshot_cube_sharp_geometry() {
+        let geometry = geometry::cube_sharp_geometry([0.0; 3], 1.0);
         let v2v = mesh_topology_analysis::vertex_to_vertex_topology(&geometry);
         let f2f = mesh_topology_analysis::face_to_face_topology(&geometry);
 
diff --git a/src/mesh_tools.rs b/src/mesh_tools.rs
index eca7931..5860a9f 100644
--- a/src/mesh_tools.rs
+++ b/src/mesh_tools.rs
@@ -324,6 +324,16 @@ mod tests {
         Geometry::from_triangle_faces_with_vertices_and_normals(faces, vertices, vertex_normals)
     }
 
+    fn empty_geometry() -> Geometry {
+        let vertices = vec![];
+
+        let vertex_normals = vec![];
+
+        let faces = vec![];
+
+        Geometry::from_triangle_faces_with_vertices_and_normals(faces, vertices, vertex_normals)
+    }
+
     fn tessellated_triangle_with_island_geometry() -> Geometry {
         let vertices = vec![
             Point3::new(-2.0, -2.0, 0.0),
@@ -529,7 +539,7 @@ mod tests {
 
     #[test]
     fn test_separate_isolated_meshes_returns_similar_for_cube() {
-        let geometry = geometry::cube_sharp([0.0, 0.0, 0.0], 1.0);
+        let geometry = geometry::cube_sharp_geometry([0.0, 0.0, 0.0], 1.0);
 
         let calculated_geometries = separate_isolated_meshes(&geometry);
 
@@ -568,7 +578,7 @@ mod tests {
     }
 
     #[test]
-    fn test_weld_tesselated_triangle() {
+    fn test_weld_tessellated_triangle() {
         let geometry = tessellated_triangle_geometry_for_welding();
         let geometry_after_welding_correct = tessellated_triangle_geometry_after_welding();
 
@@ -594,6 +604,26 @@ mod tests {
         ));
     }
 
+    #[test]
+    fn test_join_meshes_tessellated_triangle_and_empty() {
+        let tessellated_triangle_geometry = tessellated_triangle_geometry();
+        let empty_geometry = empty_geometry();
+
+        let calculated_geometry = join_meshes(&tessellated_triangle_geometry, &empty_geometry);
+
+        assert_eq!(&tessellated_triangle_geometry, &calculated_geometry);
+    }
+
+    #[test]
+    fn test_join_meshes_tessellated_empty_and_triangle() {
+        let empty_geometry = empty_geometry();
+        let tessellated_triangle_geometry = tessellated_triangle_geometry();
+
+        let calculated_geometry = join_meshes(&empty_geometry, &tessellated_triangle_geometry);
+
+        assert_eq!(&tessellated_triangle_geometry, &calculated_geometry);
+    }
+
     #[test]
     fn test_join_meshes_returns_tessellated_triangle_with_island() {
         let tessellated_triangle = tessellated_triangle_geometry();
diff --git a/src/operations/shrink_wrap.rs b/src/operations/shrink_wrap.rs
index 590d468..370beaf 100644
--- a/src/operations/shrink_wrap.rs
+++ b/src/operations/shrink_wrap.rs
@@ -10,7 +10,7 @@ pub struct ShrinkWrapParams<'a> {
 
 pub fn shrink_wrap(params: ShrinkWrapParams) -> Geometry {
     let (center, radius) = geometry::compute_bounding_sphere(slice::from_ref(&params.geometry));
-    let mut sphere_geometry = geometry::uv_sphere(
+    let mut sphere_geometry = geometry::uv_sphere_geometry(
         center.coords.into(),
         radius,
         params.sphere_density,
diff --git a/src/plane_tools.rs b/src/plane_tools.rs
new file mode 100644
index 0000000..2130196
--- /dev/null
+++ b/src/plane_tools.rs
@@ -0,0 +1,168 @@
+use std::f32;
+
+use nalgebra::base::Vector3;
+use nalgebra::geometry::Point3;
+
+use crate::geometry::Plane;
+
+/// Fit a plane to a collection of points. Fast, and accurate to within a few
+/// degrees. Returns None if the points do not span a plane.
+///
+/// The resulting normal is flipped randomly as well as the rotation of the X
+/// and Y vector around the normal is random. The result is, nevertheless,
+/// correct.
+///
+/// https://www.ilikebigbits.com/2017_09_25_plane_from_points_2.html
+#[allow(dead_code)]
+pub fn plane_fit(points: &[Point3<f32>]) -> Option<Plane> {
+    let n = points.len();
+    // Not enough points to calculate a plane.
+    if n < 3 {
+        return None;
+    }
+
+    let mut sum = Vector3::zeros();
+    for p in points {
+        sum += p.coords;
+    }
+    let centroid = sum * (1.0 / (n as f32));
+
+    // Calculate full 3x3 covariance matrix, excluding symmetries:
+    let mut xx = 0.0;
+    let mut xy = 0.0;
+    let mut xz = 0.0;
+    let mut yy = 0.0;
+    let mut yz = 0.0;
+    let mut zz = 0.0;
+
+    for p in points {
+        let r = p - centroid;
+        xx += r.x * r.x;
+        xy += r.x * r.y;
+        xz += r.x * r.z;
+        yy += r.y * r.y;
+        yz += r.y * r.z;
+        zz += r.z * r.z;
+    }
+
+    xx /= n as f32;
+    xy /= n as f32;
+    xz /= n as f32;
+    yy /= n as f32;
+    yz /= n as f32;
+    zz /= n as f32;
+
+    let mut weighted_dir = Vector3::zeros();
+
+    let det_x = yy * zz - yz * yz;
+    let axis_dir = Vector3::new(det_x, xz * yz - xy * zz, xy * yz - xz * yy);
+    let mut weight = det_x * det_x;
+    if weighted_dir.dot(&axis_dir) < 0.0 {
+        weight = -weight;
+    }
+    weighted_dir += axis_dir * weight;
+
+    let det_y = xx * zz - xz * xz;
+    let axis_dir = Vector3::new(xz * yz - xy * zz, det_y, xy * xz - yz * xx);
+    let mut weight = det_y * det_y;
+    if weighted_dir.dot(&axis_dir) < 0.0 {
+        weight = -weight;
+    }
+    weighted_dir += axis_dir * weight;
+
+    let det_z = xx * yy - xy * xy;
+    let axis_dir = Vector3::new(xy * yz - xz * yy, xy * xz - yz * xx, det_z);
+    let mut weight = det_z * det_z;
+    if weighted_dir.dot(&axis_dir) < 0.0 {
+        weight = -weight;
+    }
+    weighted_dir += axis_dir * weight;
+
+    let normal = weighted_dir.normalize();
+    if normal.x.is_finite() && normal.y.is_finite() && normal.z.is_finite() {
+        Some(Plane::from_origin_and_normal(
+            &Point3::from(centroid),
+            &normal,
+        ))
+    } else {
+        None
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    /// The test compares calculated values to the result of a similar function
+    /// in Grasshopper. The internal logic of the Grasshopper function is
+    /// unknown, therefore the resulting plane is flipped or rotated around its
+    /// normal differently. The origin of a plane fitted in Grasshopper is also
+    /// located randomly.
+    #[test]
+    fn test_plane_tools_plane_fit_random_seed_1() {
+        let points = vec![
+            Point3::new(2.486686, 1.10744, 0.934021),
+            Point3::new(8.758215, 7.961443, 0.440452),
+            Point3::new(0.960045, 9.516898, 0.965176),
+            Point3::new(9.142283, 0.918479, 1.504984),
+            Point3::new(4.419898, 6.225771, 1.422512),
+            Point3::new(9.717592, 4.613409, 1.807314),
+            Point3::new(0.23115, 5.332513, 0.465347),
+            Point3::new(6.13154, 3.183633, 0.808695),
+            Point3::new(5.983811, 0.062063, 1.120022),
+            Point3::new(2.671959, 3.858621, 0.598954),
+            Point3::new(4.155326, 9.551214, 0.09266),
+            Point3::new(6.821242, 9.279189, 1.344678),
+            Point3::new(8.870291, 2.748636, 0.067714),
+            Point3::new(2.329386, 7.446438, 1.592039),
+            Point3::new(0.037465, 2.681375, 0.790804),
+        ];
+
+        let plane_calculated = plane_fit(&points).expect("Plane not created");
+
+        let origin_correct = Point3::new(4.8477926, 4.965808, 0.9303582);
+        let normal_correct = Vector3::new(-0.026102118, 0.009860026, 0.99961066);
+
+        assert_eq!(plane_calculated.origin, origin_correct);
+        assert_eq!(plane_calculated.normal(), normal_correct);
+    }
+
+    /// The test compares calculated values to the result of a similar function
+    /// in Grasshopper. The internal logic of the Grasshopper function is
+    /// unknown, therefore the resulting plane is flipped or rotated around its
+    /// normal differently. The origin of a plane fitted in Grasshopper is also
+    /// located randomly.
+    #[test]
+    fn test_plane_tools_plane_fit_random_seed_12() {
+        let points = vec![
+            Point3::new(9.95347, 3.383488, 0.311757),
+            Point3::new(0.020258, 9.610504, 0.822709),
+            Point3::new(1.911678, 0.818737, 0.044826),
+            Point3::new(6.037565, 8.114436, 1.005404),
+            Point3::new(0.27844, 4.986335, 1.130643),
+            Point3::new(5.880629, 3.86344, 1.481233),
+            Point3::new(8.124532, 0.28451, 0.996495),
+            Point3::new(9.404667, 9.729843, 1.884917),
+            Point3::new(8.900096, 6.551787, 1.322558),
+            Point3::new(3.227978, 9.941923, 1.257427),
+            Point3::new(1.905207, 7.259329, 0.053678),
+            Point3::new(4.071256, 1.187643, 1.063247),
+            Point3::new(3.860367, 5.956172, 1.921102),
+            Point3::new(2.39709, 3.30792, 0.28436),
+            Point3::new(0.301991, 2.241202, 1.657795),
+            Point3::new(0.453235, 7.417713, 1.894652),
+            Point3::new(6.14066, 1.697522, 0.516279),
+            Point3::new(6.926976, 6.209543, 0.319568),
+            Point3::new(4.112988, 7.534449, 0.266323),
+            Point3::new(9.237105, 8.553053, 0.030565),
+        ];
+
+        let plane_calculated = plane_fit(&points).expect("Plane not created");
+
+        let origin_correct = Point3::new(4.65731, 5.4324775, 0.913277);
+        let normal_correct = Vector3::new(-0.021554187, 0.032416277, -0.999242);
+
+        assert_eq!(plane_calculated.origin, origin_correct);
+        assert_eq!(plane_calculated.normal(), normal_correct);
+    }
+}
diff --git a/src/snapshots/tests__cube_sharp_after_1_iteration_of_loop_subdivision.snap b/src/snapshots/tests__cube_sharp_after_1_iteration_of_loop_subdivision.snap
index 29dfa93..66359d2 100644
--- a/src/snapshots/tests__cube_sharp_after_1_iteration_of_loop_subdivision.snap
+++ b/src/snapshots/tests__cube_sharp_after_1_iteration_of_loop_subdivision.snap
@@ -811,244 +811,244 @@ expression: "&subdivided_geometry"
   ],
   "normals": [
     [
-      -0.25,
-      0.625,
-      -0.125
+      -0.36514837,
+      0.9128709,
+      -0.18257418
     ],
     [
-      -0.0625,
-      0.359375,
-      0.09375
+      -0.16594797,
+      0.9542008,
+      0.24892195
     ],
     [
-      -0.015625,
-      0.46875,
-      0.15625
+      -0.031606976,
+      0.9482093,
+      0.31606978
     ],
     [
-      -0.125,
-      0.5625,
-      0.1875
+      -0.20628424,
+      0.9282791,
+      0.30942637
     ],
     [
-      0.15625,
-      0.46875,
-      -0.015625
+      0.31606978,
+      0.9482093,
+      -0.031606976
     ],
     [
-      0.09375,
-      0.359375,
-      -0.0625
+      0.24892195,
+      0.9542008,
+      -0.16594797
     ],
     [
-      -0.125,
-      0.625,
-      -0.25
+      -0.18257418,
+      0.9128709,
+      -0.36514837
     ],
     [
-      0.1875,
-      0.5625,
-      -0.125
+      0.30942637,
+      0.9282791,
+      -0.20628424
     ],
     [
-      0.015625,
-      -0.46875,
-      -0.15625
+      0.031606976,
+      -0.9482093,
+      -0.31606978
     ],
     [
-      0.0625,
-      -0.359375,
-      -0.09375
+      0.16594797,
+      -0.9542008,
+      -0.24892195
     ],
     [
-      0.25,
-      -0.625,
-      0.125
+      0.36514837,
+      -0.9128709,
+      0.18257418
     ],
     [
-      0.125,
-      -0.5625,
-      -0.1875
+      0.20628424,
+      -0.9282791,
+      -0.30942637
     ],
     [
-      0.125,
-      -0.625,
-      0.25
+      0.18257418,
+      -0.9128709,
+      0.36514837
     ],
     [
-      -0.09375,
-      -0.359375,
-      0.0625
+      -0.24892195,
+      -0.9542008,
+      0.16594797
     ],
     [
-      -0.15625,
-      -0.46875,
-      0.015625
+      -0.31606978,
+      -0.9482093,
+      0.031606976
     ],
     [
-      -0.1875,
-      -0.5625,
-      0.125
+      -0.30942637,
+      -0.9282791,
+      0.20628424
     ],
     [
-      -0.09375,
-      -0.0625,
-      0.359375
+      -0.24892195,
+      -0.16594797,
+      0.9542008
     ],
     [
-      0.125,
-      -0.25,
-      0.625
+      0.18257418,
+      -0.36514837,
+      0.9128709
     ],
     [
-      -0.15625,
-      -0.015625,
-      0.46875
+      -0.31606978,
+      -0.031606976,
+      0.9482093
     ],
     [
-      -0.1875,
-      -0.125,
-      0.5625
+      -0.30942637,
+      -0.20628424,
+      0.9282791
     ],
     [
-      0.0625,
-      0.09375,
-      0.359375
+      0.16594797,
+      0.24892195,
+      0.9542008
     ],
     [
-      0.015625,
-      0.15625,
-      0.46875
+      0.031606976,
+      0.31606978,
+      0.9482093
     ],
     [
-      0.25,
-      -0.125,
-      0.625
+      0.36514837,
+      -0.18257418,
+      0.9128709
     ],
     [
-      0.125,
-      0.1875,
-      0.5625
+      0.20628424,
+      0.30942637,
+      0.9282791
     ],
     [
-      0.15625,
-      0.015625,
-      -0.46875
+      0.31606978,
+      0.031606976,
+      -0.9482093
     ],
     [
-      -0.125,
-      0.25,
-      -0.625
+      -0.18257418,
+      0.36514837,
+      -0.9128709
     ],
     [
-      0.09375,
-      0.0625,
-      -0.359375
+      0.24892195,
+      0.16594797,
+      -0.9542008
     ],
     [
-      0.1875,
-      0.125,
-      -0.5625
+      0.30942637,
+      0.20628424,
+      -0.9282791
     ],
     [
-      -0.25,
-      0.125,
-      -0.625
+      -0.36514837,
+      0.18257418,
+      -0.9128709
     ],
     [
-      -0.015625,
-      -0.15625,
-      -0.46875
+      -0.031606976,
+      -0.31606978,
+      -0.9482093
     ],
     [
-      -0.0625,
-      -0.09375,
-      -0.359375
+      -0.16594797,
+      -0.24892195,
+      -0.9542008
     ],
     [
-      -0.125,
-      -0.1875,
-      -0.5625
+      -0.20628424,
+      -0.30942637,
+      -0.9282791
     ],
     [
-      0.625,
-      -0.125,
-      0.25
+      0.9128709,
+      -0.18257418,
+      0.36514837
     ],
     [
-      0.46875,
-      0.15625,
-      0.015625
+      0.9482093,
+      0.31606978,
+      0.031606976
     ],
     [
-      0.359375,
-      0.09375,
-      0.0625
+      0.9542008,
+      0.24892195,
+      0.16594797
     ],
     [
-      0.5625,
-      0.1875,
-      0.125
+      0.9282791,
+      0.30942637,
+      0.20628424
     ],
     [
-      0.46875,
-      -0.015625,
-      -0.15625
+      0.9482093,
+      -0.031606976,
+      -0.31606978
     ],
     [
-      0.625,
-      -0.25,
-      0.125
+      0.9128709,
+      -0.36514837,
+      0.18257418
     ],
     [
-      0.359375,
-      -0.0625,
-      -0.09375
+      0.9542008,
+      -0.16594797,
+      -0.24892195
     ],
     [
-      0.5625,
-      -0.125,
-      -0.1875
+      0.9282791,
+      -0.20628424,
+      -0.30942637
     ],
     [
-      -0.359375,
-      -0.09375,
-      -0.0625
+      -0.9542008,
+      -0.24892195,
+      -0.16594797
     ],
     [
-      -0.46875,
-      -0.15625,
-      -0.015625
+      -0.9482093,
+      -0.31606978,
+      -0.031606976
     ],
     [
-      -0.625,
-      0.125,
-      -0.25
+      -0.9128709,
+      0.18257418,
+      -0.36514837
     ],
     [
-      -0.5625,
-      -0.1875,
-      -0.125
+      -0.9282791,
+      -0.30942637,
+      -0.20628424
     ],
     [
-      -0.359375,
-      0.0625,
-      0.09375
+      -0.9542008,
+      0.16594797,
+      0.24892195
     ],
     [
-      -0.625,
-      0.25,
-      -0.125
+      -0.9128709,
+      0.36514837,
+      -0.18257418
     ],
     [
-      -0.46875,
-      0.015625,
-      0.15625
+      -0.9482093,
+      0.031606976,
+      0.31606978
     ],
     [
-      -0.5625,
-      0.125,
-      0.1875
+      -0.9282791,
+      0.20628424,
+      0.30942637
     ]
   ]
 }
diff --git a/src/snapshots/tests__triple_torus_after_1_iteration_of_laplacian_smoothing.snap b/src/snapshots/tests__triple_torus_after_1_iteration_of_laplacian_smoothing.snap
index d58dac7..0d9a09d 100644
--- a/src/snapshots/tests__triple_torus_after_1_iteration_of_laplacian_smoothing.snap
+++ b/src/snapshots/tests__triple_torus_after_1_iteration_of_laplacian_smoothing.snap
@@ -750,232 +750,232 @@ expression: "&relaxed_geometry"
     [
       -0.0,
       0.0,
-      0.42524105
+      1.0
     ],
     [
       0.0,
       -0.0,
-      1.0747586
+      1.0
     ],
     [
       0.0,
       0.0,
-      1.0747575
+      1.0
     ],
     [
       0.0,
       0.0,
-      0.4252399
+      1.0
     ],
     [
       0.0,
       0.0,
-      0.42524105
+      1.0
     ],
     [
       0.0,
       0.0,
-      0.42524052
+      1.0
     ],
     [
-      -0.36826876,
-      0.6378608,
-      -0.2126205
+      -0.4803841,
+      0.83205044,
+      -0.27735046
     ],
     [
-      0.9307687,
-      -1.6121385,
-      -0.53737986
+      0.4803845,
+      -0.83205026,
+      -0.27735028
     ],
     [
       -0.0,
       0.0,
-      0.42524064
+      1.0
     ],
     [
       0.0,
       -0.0,
-      1.0747588
+      1.0
     ],
     [
       0.0,
       0.0,
-      1.0747579
+      1.0
     ],
     [
-      1.6506,
-      -0.040595055,
-      -0.4030337
+      0.9711824,
+      -0.023885377,
+      -0.23713756
     ],
     [
-      -1.6506,
-      0.040595055,
-      -0.5905341
+      -0.94130254,
+      0.02315051,
+      -0.33676922
     ],
     [
-      -0.36826876,
-      -0.6378608,
-      -0.42524055
+      -0.43301237,
+      -0.7500001,
+      -0.5000001
     ],
     [
-      0.8604562,
-      1.165595,
-      -0.53737926
+      0.5568423,
+      0.7543123,
+      -0.3477638
     ],
     [
-      0.7365384,
+      0.96076906,
       0.0,
-      -0.21261996
+      -0.27734965
     ],
     [
-      -1.8615384,
+      -0.960769,
       -0.0,
-      -0.53737897
+      -0.27734968
     ],
     [
-      -1.5802882,
+      -0.98974323,
       -0.0,
-      -0.22809559
+      -0.14285754
     ],
     [
-      1.8615382,
+      0.91766334,
       0.0,
-      -0.8060672
+      -0.3973587
     ],
     [
-      0.71983194,
-      -1.165595,
-      -0.7171425
+      0.465517,
+      -0.75379306,
+      -0.46377778
     ],
     [
-      -0.7901439,
-      -1.2061901,
-      -0.2686903
+      -0.5386962,
+      -0.822344,
+      -0.18318492
     ],
     [
-      0.7901439,
-      1.2061901,
-      -0.6436888
+      0.50037605,
+      0.7638465,
+      -0.40763015
     ],
     [
-      -0.71983194,
-      1.165595,
-      -0.86404794
+      -0.44442973,
+      0.7196473,
+      -0.5334698
     ],
     [
       0.0,
       0.0,
-      1.0747588
+      1.0
     ],
     [
       0.0,
       0.0,
-      0.42524105
+      1.0
     ],
     [
       0.0,
       0.0,
-      0.42523944
+      1.0
     ],
     [
       -0.0,
       0.0,
-      1.0747578
+      1.0
     ],
     [
       0.0,
       0.0,
-      1.0747586
+      1.0
     ],
     [
       0.0,
       -0.0,
-      1.0747595
+      1.0
     ],
     [
-      -0.7901437,
-      1.2061901,
-      -0.26869023
+      -0.53869617,
+      0.82234406,
+      -0.18318489
     ],
     [
-      0.7901437,
-      -1.2061901,
-      -0.6436887
+      0.500376,
+      -0.7638466,
+      -0.4076301
     ],
     [
       0.0,
       0.0,
-      1.0747594
+      1.0
     ],
     [
       0.0,
       0.0,
-      0.425241
+      1.0
     ],
     [
       0.0,
       0.0,
-      0.42523992
+      1.0
     ],
     [
-      0.7365375,
+      0.960769,
       0.0,
-      -0.21261972
+      -0.27734968
     ],
     [
-      -1.8615375,
+      -0.96076906,
       -0.0,
-      -0.5373787
+      -0.2773497
     ],
     [
-      -0.8604562,
-      -1.165595,
-      -1.1250007
+      -0.46909472,
+      -0.6354472,
+      -0.61331636
     ],
     [
-      0.36826873,
-      0.6378608,
-      -0.42524043
+      0.4330124,
+      0.75000024,
+      -0.50000006
     ],
     [
-      1.5099759,
-      0.040595055,
-      -0.36243904
+      0.97204864,
+      0.02613311,
+      -0.23332053
     ],
     [
-      -1.5099759,
-      -0.040595055,
-      -0.5499396
+      -0.9393223,
+      -0.025253277,
+      -0.34210512
     ],
     [
-      -0.7365383,
+      -0.98974323,
       0.0,
-      -0.10631044
+      -0.14285752
     ],
     [
-      1.5802882,
+      0.9176634,
       0.0,
-      -0.6842828
+      -0.39735872
     ],
     [
-      0.36826953,
-      -0.6378608,
-      -0.4252402
+      0.4330132,
+      -0.74999994,
+      -0.49999958
     ],
     [
-      -0.3682689,
-      -0.6378608,
-      -0.21262044
+      -0.48038426,
+      -0.8320504,
+      -0.27735037
     ],
     [
-      0.9307689,
-      1.6121385,
-      -0.53738
+      0.48038453,
+      0.83205014,
+      -0.2773503
     ],
     [
-      -0.36826944,
-      0.6378608,
-      -0.42524108
+      -0.4330129,
+      0.74999964,
+      -0.5000004
     ]
   ]
 }
diff --git a/src/snapshots/tests__triple_torus_after_2_iteration2_of_laplacian_smoothing.snap b/src/snapshots/tests__triple_torus_after_2_iteration2_of_laplacian_smoothing.snap
index fe20458..48907e9 100644
--- a/src/snapshots/tests__triple_torus_after_2_iteration2_of_laplacian_smoothing.snap
+++ b/src/snapshots/tests__triple_torus_after_2_iteration2_of_laplacian_smoothing.snap
@@ -750,232 +750,232 @@ expression: "&relaxed_geometry"
     [
       -0.0,
       0.0,
-      0.42524105
+      1.0
     ],
     [
       0.0,
       -0.0,
-      1.0747586
+      1.0
     ],
     [
       0.0,
       0.0,
-      1.0747575
+      1.0
     ],
     [
       0.0,
       0.0,
-      0.4252399
+      1.0
     ],
     [
       0.0,
       0.0,
-      0.42524105
+      1.0
     ],
     [
       0.0,
       0.0,
-      0.42524052
+      1.0
     ],
     [
-      -0.36826876,
-      0.6378608,
-      -0.2126205
+      -0.4803841,
+      0.83205044,
+      -0.27735046
     ],
     [
-      0.9307687,
-      -1.6121385,
-      -0.53737986
+      0.4803845,
+      -0.83205026,
+      -0.27735028
     ],
     [
       -0.0,
       0.0,
-      0.42524064
+      1.0
     ],
     [
       0.0,
       -0.0,
-      1.0747588
+      1.0
     ],
     [
       0.0,
       0.0,
-      1.0747579
+      1.0
     ],
     [
-      1.6506,
-      -0.040595055,
-      -0.4030337
+      0.9711824,
+      -0.023885377,
+      -0.23713756
     ],
     [
-      -1.6506,
-      0.040595055,
-      -0.5905341
+      -0.94130254,
+      0.02315051,
+      -0.33676922
     ],
     [
-      -0.36826876,
-      -0.6378608,
-      -0.42524055
+      -0.43301237,
+      -0.7500001,
+      -0.5000001
     ],
     [
-      0.8604562,
-      1.165595,
-      -0.53737926
+      0.5568423,
+      0.7543123,
+      -0.3477638
     ],
     [
-      0.7365384,
+      0.96076906,
       0.0,
-      -0.21261996
+      -0.27734965
     ],
     [
-      -1.8615384,
+      -0.960769,
       -0.0,
-      -0.53737897
+      -0.27734968
     ],
     [
-      -1.5802882,
+      -0.98974323,
       -0.0,
-      -0.22809559
+      -0.14285754
     ],
     [
-      1.8615382,
+      0.91766334,
       0.0,
-      -0.8060672
+      -0.3973587
     ],
     [
-      0.71983194,
-      -1.165595,
-      -0.7171425
+      0.465517,
+      -0.75379306,
+      -0.46377778
     ],
     [
-      -0.7901439,
-      -1.2061901,
-      -0.2686903
+      -0.5386962,
+      -0.822344,
+      -0.18318492
     ],
     [
-      0.7901439,
-      1.2061901,
-      -0.6436888
+      0.50037605,
+      0.7638465,
+      -0.40763015
     ],
     [
-      -0.71983194,
-      1.165595,
-      -0.86404794
+      -0.44442973,
+      0.7196473,
+      -0.5334698
     ],
     [
       0.0,
       0.0,
-      1.0747588
+      1.0
     ],
     [
       0.0,
       0.0,
-      0.42524105
+      1.0
     ],
     [
       0.0,
       0.0,
-      0.42523944
+      1.0
     ],
     [
       -0.0,
       0.0,
-      1.0747578
+      1.0
     ],
     [
       0.0,
       0.0,
-      1.0747586
+      1.0
     ],
     [
       0.0,
       -0.0,
-      1.0747595
+      1.0
     ],
     [
-      -0.7901437,
-      1.2061901,
-      -0.26869023
+      -0.53869617,
+      0.82234406,
+      -0.18318489
     ],
     [
-      0.7901437,
-      -1.2061901,
-      -0.6436887
+      0.500376,
+      -0.7638466,
+      -0.4076301
     ],
     [
       0.0,
       0.0,
-      1.0747594
+      1.0
     ],
     [
       0.0,
       0.0,
-      0.425241
+      1.0
     ],
     [
       0.0,
       0.0,
-      0.42523992
+      1.0
     ],
     [
-      0.7365375,
+      0.960769,
       0.0,
-      -0.21261972
+      -0.27734968
     ],
     [
-      -1.8615375,
+      -0.96076906,
       -0.0,
-      -0.5373787
+      -0.2773497
     ],
     [
-      -0.8604562,
-      -1.165595,
-      -1.1250007
+      -0.46909472,
+      -0.6354472,
+      -0.61331636
     ],
     [
-      0.36826873,
-      0.6378608,
-      -0.42524043
+      0.4330124,
+      0.75000024,
+      -0.50000006
     ],
     [
-      1.5099759,
-      0.040595055,
-      -0.36243904
+      0.97204864,
+      0.02613311,
+      -0.23332053
     ],
     [
-      -1.5099759,
-      -0.040595055,
-      -0.5499396
+      -0.9393223,
+      -0.025253277,
+      -0.34210512
     ],
     [
-      -0.7365383,
+      -0.98974323,
       0.0,
-      -0.10631044
+      -0.14285752
     ],
     [
-      1.5802882,
+      0.9176634,
       0.0,
-      -0.6842828
+      -0.39735872
     ],
     [
-      0.36826953,
-      -0.6378608,
-      -0.4252402
+      0.4330132,
+      -0.74999994,
+      -0.49999958
     ],
     [
-      -0.3682689,
-      -0.6378608,
-      -0.21262044
+      -0.48038426,
+      -0.8320504,
+      -0.27735037
     ],
     [
-      0.9307689,
-      1.6121385,
-      -0.53738
+      0.48038453,
+      0.83205014,
+      -0.2773503
     ],
     [
-      -0.36826944,
-      0.6378608,
-      -0.42524108
+      -0.4330129,
+      0.74999964,
+      -0.5000004
     ]
   ]
 }
diff --git a/src/snapshots/tests__triple_torus_after_3_iterations_of_laplacian_smoothing.snap b/src/snapshots/tests__triple_torus_after_3_iterations_of_laplacian_smoothing.snap
index b49f87d..c381f23 100644
--- a/src/snapshots/tests__triple_torus_after_3_iterations_of_laplacian_smoothing.snap
+++ b/src/snapshots/tests__triple_torus_after_3_iterations_of_laplacian_smoothing.snap
@@ -750,232 +750,232 @@ expression: "&relaxed_geometry"
     [
       -0.0,
       0.0,
-      0.42524105
+      1.0
     ],
     [
       0.0,
       -0.0,
-      1.0747586
+      1.0
     ],
     [
       0.0,
       0.0,
-      1.0747575
+      1.0
     ],
     [
       0.0,
       0.0,
-      0.4252399
+      1.0
     ],
     [
       0.0,
       0.0,
-      0.42524105
+      1.0
     ],
     [
       0.0,
       0.0,
-      0.42524052
+      1.0
     ],
     [
-      -0.36826876,
-      0.6378608,
-      -0.2126205
+      -0.4803841,
+      0.83205044,
+      -0.27735046
     ],
     [
-      0.9307687,
-      -1.6121385,
-      -0.53737986
+      0.4803845,
+      -0.83205026,
+      -0.27735028
     ],
     [
       -0.0,
       0.0,
-      0.42524064
+      1.0
     ],
     [
       0.0,
       -0.0,
-      1.0747588
+      1.0
     ],
     [
       0.0,
       0.0,
-      1.0747579
+      1.0
     ],
     [
-      1.6506,
-      -0.040595055,
-      -0.4030337
+      0.9711824,
+      -0.023885377,
+      -0.23713756
     ],
     [
-      -1.6506,
-      0.040595055,
-      -0.5905341
+      -0.94130254,
+      0.02315051,
+      -0.33676922
     ],
     [
-      -0.36826876,
-      -0.6378608,
-      -0.42524055
+      -0.43301237,
+      -0.7500001,
+      -0.5000001
     ],
     [
-      0.8604562,
-      1.165595,
-      -0.53737926
+      0.5568423,
+      0.7543123,
+      -0.3477638
     ],
     [
-      0.7365384,
+      0.96076906,
       0.0,
-      -0.21261996
+      -0.27734965
     ],
     [
-      -1.8615384,
+      -0.960769,
       -0.0,
-      -0.53737897
+      -0.27734968
     ],
     [
-      -1.5802882,
+      -0.98974323,
       -0.0,
-      -0.22809559
+      -0.14285754
     ],
     [
-      1.8615382,
+      0.91766334,
       0.0,
-      -0.8060672
+      -0.3973587
     ],
     [
-      0.71983194,
-      -1.165595,
-      -0.7171425
+      0.465517,
+      -0.75379306,
+      -0.46377778
     ],
     [
-      -0.7901439,
-      -1.2061901,
-      -0.2686903
+      -0.5386962,
+      -0.822344,
+      -0.18318492
     ],
     [
-      0.7901439,
-      1.2061901,
-      -0.6436888
+      0.50037605,
+      0.7638465,
+      -0.40763015
     ],
     [
-      -0.71983194,
-      1.165595,
-      -0.86404794
+      -0.44442973,
+      0.7196473,
+      -0.5334698
     ],
     [
       0.0,
       0.0,
-      1.0747588
+      1.0
     ],
     [
       0.0,
       0.0,
-      0.42524105
+      1.0
     ],
     [
       0.0,
       0.0,
-      0.42523944
+      1.0
     ],
     [
       -0.0,
       0.0,
-      1.0747578
+      1.0
     ],
     [
       0.0,
       0.0,
-      1.0747586
+      1.0
     ],
     [
       0.0,
       -0.0,
-      1.0747595
+      1.0
     ],
     [
-      -0.7901437,
-      1.2061901,
-      -0.26869023
+      -0.53869617,
+      0.82234406,
+      -0.18318489
     ],
     [
-      0.7901437,
-      -1.2061901,
-      -0.6436887
+      0.500376,
+      -0.7638466,
+      -0.4076301
     ],
     [
       0.0,
       0.0,
-      1.0747594
+      1.0
     ],
     [
       0.0,
       0.0,
-      0.425241
+      1.0
     ],
     [
       0.0,
       0.0,
-      0.42523992
+      1.0
     ],
     [
-      0.7365375,
+      0.960769,
       0.0,
-      -0.21261972
+      -0.27734968
     ],
     [
-      -1.8615375,
+      -0.96076906,
       -0.0,
-      -0.5373787
+      -0.2773497
     ],
     [
-      -0.8604562,
-      -1.165595,
-      -1.1250007
+      -0.46909472,
+      -0.6354472,
+      -0.61331636
     ],
     [
-      0.36826873,
-      0.6378608,
-      -0.42524043
+      0.4330124,
+      0.75000024,
+      -0.50000006
     ],
     [
-      1.5099759,
-      0.040595055,
-      -0.36243904
+      0.97204864,
+      0.02613311,
+      -0.23332053
     ],
     [
-      -1.5099759,
-      -0.040595055,
-      -0.5499396
+      -0.9393223,
+      -0.025253277,
+      -0.34210512
     ],
     [
-      -0.7365383,
+      -0.98974323,
       0.0,
-      -0.10631044
+      -0.14285752
     ],
     [
-      1.5802882,
+      0.9176634,
       0.0,
-      -0.6842828
+      -0.39735872
     ],
     [
-      0.36826953,
-      -0.6378608,
-      -0.4252402
+      0.4330132,
+      -0.74999994,
+      -0.49999958
     ],
     [
-      -0.3682689,
-      -0.6378608,
-      -0.21262044
+      -0.48038426,
+      -0.8320504,
+      -0.27735037
     ],
     [
-      0.9307689,
-      1.6121385,
-      -0.53738
+      0.48038453,
+      0.83205014,
+      -0.2773503
     ],
     [
-      -0.36826944,
-      0.6378608,
-      -0.42524108
+      -0.4330129,
+      0.74999964,
+      -0.5000004
     ]
   ]
 }
diff --git a/src/snapshots/tests__uv_sphere_2_3_after_1_iteration_of_loop_subdivision.snap b/src/snapshots/tests__uv_sphere_2_3_after_1_iteration_of_loop_subdivision.snap
index 95876fd..7df8152 100644
--- a/src/snapshots/tests__uv_sphere_2_3_after_1_iteration_of_loop_subdivision.snap
+++ b/src/snapshots/tests__uv_sphere_2_3_after_1_iteration_of_loop_subdivision.snap
@@ -811,244 +811,244 @@ expression: "&subdivided_geometry"
   ],
   "normals": [
     [
-      0.13945313,
-      0.16982217,
-      -0.034505695
+      0.6269384,
+      0.7634683,
+      -0.155127
     ],
     [
-      0.011718733,
-      0.16102658,
-      -0.024356978
+      0.071771055,
+      0.9862029,
+      -0.14917365
     ],
     [
-      0.03632813,
-      0.1887665,
-      -0.006089226
+      0.1888875,
+      0.9814882,
+      -0.03166083
     ],
     [
-      0.041015625,
-      0.21312343,
-      -0.010148734
+      0.18877599,
+      0.9809087,
+      -0.046709936
     ],
     [
-      0.07734374,
-      0.20568106,
-      0.0345057
+      0.34771365,
+      0.92467874,
+      0.155127
     ],
     [
-      0.13359377,
-      0.09066207,
-      0.024356946
+      0.8181911,
+      0.5552572,
+      0.14917341
     ],
     [
-      0.14531249,
-      0.12584431,
-      0.006089244
+      0.75554997,
+      0.65432554,
+      0.03166093
     ],
     [
-      0.1640625,
-      0.1420823,
-      0.010148725
+      0.7551038,
+      0.6539391,
+      0.046709888
     ],
     [
-      -0.21679686,
-      0.035858847,
-      -0.03450571
+      -0.9746521,
+      0.16121037,
+      -0.15512708
     ],
     [
-      -0.14531249,
-      -0.07036459,
-      -0.024356976
+      -0.88996226,
+      -0.43094593,
+      -0.14917362
     ],
     [
-      -0.18164065,
-      -0.0629222,
-      -0.0060892324
+      -0.94443744,
+      -0.3271629,
+      -0.03166086
     ],
     [
-      -0.20507812,
-      -0.07104119,
-      -0.010148746
+      -0.9438797,
+      -0.3269697,
+      -0.04670998
     ],
     [
-      -0.21679689,
-      -0.035858907,
-      0.034505717
+      -0.97465205,
+      -0.16121061,
+      0.15512708
     ],
     [
-      -0.14531252,
-      0.07036455,
-      0.024356967
+      -0.88996243,
+      0.4309457,
+      0.14917356
     ],
     [
-      -0.18164062,
-      0.06292215,
-      0.006089235
+      -0.9444375,
+      0.3271627,
+      0.03166088
     ],
     [
-      -0.20507814,
-      0.07104114,
-      0.01014874
+      -0.9438798,
+      0.32696947,
+      0.046709955
     ],
     [
-      0.07734374,
-      -0.20568103,
-      -0.0345057
+      0.3477137,
+      -0.92467874,
+      -0.15512703
     ],
     [
-      0.13359375,
-      -0.09066201,
-      -0.024356961
+      0.81819123,
+      -0.55525696,
+      -0.14917354
     ],
     [
-      0.14531252,
-      -0.12584428,
-      -0.006089261
+      0.75555015,
+      -0.65432537,
+      -0.031661015
     ],
     [
-      0.1640625,
-      -0.14208226,
-      -0.010148732
+      0.75510395,
+      -0.653939,
+      -0.046709925
     ],
     [
-      0.13945314,
-      -0.16982216,
-      0.034505695
+      0.62693846,
+      -0.7634682,
+      0.155127
     ],
     [
-      0.011718752,
-      -0.16102661,
-      0.024356965
+      0.07177116,
+      -0.9862029,
+      0.14917353
     ],
     [
-      0.036328133,
-      -0.18876646,
-      0.0060892147
+      0.18888755,
+      -0.9814882,
+      0.031660777
     ],
     [
-      0.04101564,
-      -0.21312343,
-      0.010148723
+      0.18877605,
+      -0.9809087,
+      0.046709884
     ],
     [
-      0.09843751,
-      0.056832947,
-      0.08524939
+      0.69282025,
+      0.40000013,
+      0.59999996
     ],
     [
-      0.042187512,
-      0.13802283,
-      0.11569557
+      0.22807209,
+      0.7461723,
+      0.62546784
     ],
     [
-      0.005859375,
-      0.010148736,
-      0.040594947
+      0.13867503,
+      0.24019222,
+      0.96076894
     ],
     [
-      0.046875007,
-      0.08118991,
-      0.10148735
+      0.3392756,
+      0.58764267,
+      0.73455316
     ],
     [
-      -1.3038516e-8,
-      0.113665804,
-      -0.085249364
+      -9.1767376e-8,
+      0.79999995,
+      -0.6000001
     ],
     [
-      0.0984375,
-      0.105546854,
-      -0.115695566
+      0.5321681,
+      0.57060236,
+      -0.62546784
     ],
     [
-      0.005859364,
-      0.010148729,
-      -0.04059494
+      0.13867481,
+      0.24019212,
+      -0.960769
     ],
     [
-      0.046874978,
-      0.08118988,
-      -0.101487346
+      0.33927542,
+      0.58764255,
+      -0.73455316
     ],
     [
-      -0.09843752,
-      0.056832906,
-      0.08524937
+      -0.69282037,
+      0.3999999,
+      0.5999999
     ],
     [
-      -0.14062503,
-      -0.03247597,
-      0.11569558
+      -0.7602402,
+      -0.17557001,
+      0.62546784
     ],
     [
-      -0.011718751,
-      -1.1641532e-9,
-      0.040594943
+      -0.2773501,
+      -2.7552256e-8,
+      0.96076894
     ],
     [
-      -0.09375003,
-      -1.4901161e-8,
-      0.10148736
+      -0.67855126,
+      -1.07852784e-7,
+      0.7345531
     ],
     [
-      -0.09843747,
-      -0.05683293,
-      -0.085249364
+      -0.69282025,
+      -0.40000013,
+      -0.6
     ],
     [
-      -0.14062496,
-      0.032475937,
-      -0.11569558
+      -0.76024,
+      0.17556989,
+      -0.625468
     ],
     [
-      -0.01171875,
-      -1.1641532e-9,
-      -0.04059494
+      -0.27735013,
+      -2.755226e-8,
+      -0.96076894
     ],
     [
-      -0.09374998,
-      -7.450581e-9,
-      -0.10148735
+      -0.678551,
+      -5.3926403e-8,
+      -0.7345532
     ],
     [
-      9.313226e-9,
-      -0.11366585,
-      0.08524938
+      6.554811e-8,
+      -0.8000001,
+      0.59999996
     ],
     [
-      0.09843751,
-      -0.105546854,
-      0.115695596
+      0.5321681,
+      -0.57060224,
+      0.6254679
     ],
     [
-      0.005859376,
-      -0.010148735,
-      0.040594947
+      0.13867505,
+      -0.24019219,
+      0.96076894
     ],
     [
-      0.04687502,
-      -0.08118989,
-      0.10148736
+      0.33927566,
+      -0.5876425,
+      0.7345531
     ],
     [
-      0.09843751,
-      -0.056832895,
-      -0.085249364
+      0.6928204,
+      -0.39999986,
+      -0.59999996
     ],
     [
-      0.042187482,
-      -0.13802277,
-      -0.11569558
+      0.22807199,
+      -0.7461722,
+      -0.625468
     ],
     [
-      0.005859364,
-      -0.010148728,
-      -0.04059494
+      0.13867481,
+      -0.2401921,
+      -0.960769
     ],
     [
-      0.046874985,
-      -0.08118988,
-      -0.10148735
+      0.33927548,
+      -0.58764255,
+      -0.7345532
     ]
   ]
 }
diff --git a/src/vertex_tools.rs b/src/vertex_tools.rs
new file mode 100644
index 0000000..13fa0a5
--- /dev/null
+++ b/src/vertex_tools.rs
@@ -0,0 +1,1043 @@
+use std::f32;
+
+use nalgebra;
+use nalgebra::base::Vector3;
+use nalgebra::geometry::{Point2, Point3};
+
+use crate::convert::cast_usize;
+use crate::geometry::{self, Face, Geometry, Plane, UnorientedEdge};
+
+/// Compute barycentric coordinates of point P in triangle A, B, C. Returns None
+/// for degenerate triangles.
+pub fn to_barycentric(
+    a: Point2<f32>,
+    b: Point2<f32>,
+    c: Point2<f32>,
+    p: Point2<f32>,
+) -> Option<Point3<f32>> {
+    let ab = b - a;
+    let ac = c - a;
+    let pa = a - p;
+    let xs = Vector3::new(ac.x, ab.x, pa.x);
+    let ys = Vector3::new(ac.y, ab.y, pa.y);
+    let ortho = xs.cross(&ys);
+    if f32::abs(ortho.z) < 1.0 {
+        None
+    } else {
+        Some(Point3::new(
+            1.0 - (ortho.x + ortho.y) / ortho.z,
+            ortho.y / ortho.z,
+            ortho.x / ortho.z,
+        ))
+    }
+}
+
+/// Checks if a point lies in a triangle.
+///
+/// https://math.stackexchange.com/questions/4322/check-whether-a-point-is-within-a-3d-triangle
+fn is_point_in_triangle(
+    point: &Point3<f32>,
+    triangle_vertices: (&Point3<f32>, &Point3<f32>, &Point3<f32>),
+) -> bool {
+    // If the triangle is degenerated into a point, check if the point is equal
+    // to the test point
+    if triangle_vertices.0 == triangle_vertices.1 && triangle_vertices.0 == triangle_vertices.2 {
+        return point == triangle_vertices.0;
+    }
+
+    // If the triangle is degenerated into a line, check if the point lies on
+    // the line
+    if triangle_vertices.0 == triangle_vertices.1 {
+        return is_point_on_line_clamped(point, triangle_vertices.0, triangle_vertices.2);
+    }
+    if triangle_vertices.0 == triangle_vertices.2 || triangle_vertices.1 == triangle_vertices.2 {
+        return is_point_on_line_clamped(point, triangle_vertices.0, triangle_vertices.1);
+    }
+
+    let plane = Plane::from_three_points(
+        triangle_vertices.0,
+        triangle_vertices.1,
+        triangle_vertices.2,
+    );
+
+    if is_point_on_plane(point, &plane.origin, &plane.normal()) {
+        let a = Point2::origin();
+        let b = Point2::from((triangle_vertices.1 - triangle_vertices.0).xy());
+        let c = Point2::from((triangle_vertices.2 - triangle_vertices.0).xy());
+        let p = Point2::from((point - triangle_vertices.0).xy());
+        let barycentric_point = to_barycentric(a, b, c, p).expect("The triangle is degenerate");
+
+        barycentric_point.x >= 0.0
+            && barycentric_point.x <= 1.0
+            && barycentric_point.y >= 0.0
+            && barycentric_point.y <= 1.0
+            && barycentric_point.z >= 0.0
+            && barycentric_point.z <= 1.0
+            && approx::relative_eq!(
+                barycentric_point.x + barycentric_point.y + barycentric_point.z,
+                1.0
+            )
+    } else {
+        false
+    }
+}
+
+/// The MllerTrumbore ray-triangle intersection algorithm is a fast method for
+/// calculating the intersection of a ray and a triangle in three dimensions
+/// without the need of precomputation of the plane equation of the plane
+/// containing the triangle.
+///
+/// https://en.wikipedia.org/wiki/MllerTrumbore_intersection_algorithm
+/// http://webserver2.tecgraf.puc-rio.br/~mgattass/cg/trbRR/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf
+fn ray_intersects_triangle(
+    ray_origin: &Point3<f32>,
+    ray_vector: &Vector3<f32>,
+    triangle_vertices: (&Point3<f32>, &Point3<f32>, &Point3<f32>),
+) -> Option<PulledPointWithDistance> {
+    if is_point_in_triangle(ray_origin, triangle_vertices) {
+        return Some(PulledPointWithDistance {
+            point: *ray_origin,
+            distance: 0.0,
+        });
+    }
+    let ray_vector_normalized = ray_vector.normalize();
+    let edge_1_vector = triangle_vertices.1 - triangle_vertices.0;
+    let edge_2_vector = triangle_vertices.2 - triangle_vertices.0;
+    // If the ray is parallel to the triangle, a vector perpendicular to the ray
+    // and one of the triangle edges
+    let perpendicular_vector = ray_vector_normalized.cross(&edge_2_vector);
+    // will be also perpendicular to the other triangle edge.
+    let determinant = edge_1_vector.dot(&perpendicular_vector);
+    // Which means the ray is parallel to the tested triangle.
+    if approx::relative_eq!(determinant, 0.0) {
+        return None;
+    }
+    let inverse_determinant = 1.0 / determinant;
+    let tangent_vector = ray_origin - triangle_vertices.0;
+    let u_parameter = inverse_determinant * tangent_vector.dot(&perpendicular_vector);
+    // The ray intersects the triangle plane outside of the triangle -> the ray
+    // doesn't intersect the triangle
+    if u_parameter < 0.0 || u_parameter > 1.0 {
+        return None;
+    }
+    let q_vector = tangent_vector.cross(&edge_1_vector);
+    let v_parameter = inverse_determinant * ray_vector_normalized.dot(&q_vector);
+    // The ray intersects the triangle plane outside of the triangle -> the ray
+    // doesn't intersect the triangle
+    if v_parameter < 0.0 || u_parameter + v_parameter > 1.0 {
+        return None;
+    }
+    // The t_parameter is the relative position of the intersection point on the
+    // ray line.
+    let t_parameter = inverse_determinant * edge_2_vector.dot(&q_vector);
+    // Ray-triangle intersection
+    if t_parameter > f32::EPSILON && t_parameter < 1.0 / f32::EPSILON {
+        Some(PulledPointWithDistance {
+            point: ray_origin + ray_vector_normalized.scale(t_parameter),
+            distance: t_parameter.abs(),
+        })
+    } else {
+        None
+    }
+}
+
+/// Test if an arbitrary point lies on a plane.
+///
+/// https://stackoverflow.com/questions/17227149/using-dot-product-to-determine-if-point-lies-on-a-plane
+fn is_point_on_plane(
+    point: &Point3<f32>,
+    point_on_plane: &Point3<f32>,
+    plane_normal: &Vector3<f32>,
+) -> bool {
+    let vector_from_plane_point_to_point = point - point_on_plane;
+    point == point_on_plane
+        || approx::relative_eq!(
+            vector_from_plane_point_to_point
+                .normalize()
+                .dot(&plane_normal.normalize()),
+            0.0
+        )
+}
+
+/// Find an intersection or a ray and a plane.
+///
+/// https://rosettacode.org/wiki/Find_the_intersection_of_a_line_with_a_plane#Rust
+/// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-plane-and-ray-disk-intersection
+fn ray_intersects_plane(
+    ray_origin: &Point3<f32>,
+    ray_vector: &Vector3<f32>,
+    plane: &Plane,
+) -> Option<PulledPointWithDistance> {
+    let plane_normal = plane.normal();
+    if is_point_on_plane(ray_origin, &plane.origin, &plane_normal) {
+        return Some(PulledPointWithDistance {
+            point: *ray_origin,
+            distance: 0.0,
+        });
+    }
+    let ray_vector_normalized = ray_vector.normalize();
+    let denominator = ray_vector_normalized.dot(&plane_normal);
+    // The ray is parallel to the plane
+    if approx::relative_eq!(denominator, 0.0) {
+        None
+    } else {
+        let ray_to_plane_origin_vector = ray_origin - plane.origin;
+        let t_parameter = ray_to_plane_origin_vector.dot(&plane_normal) / denominator;
+        Some(PulledPointWithDistance {
+            point: ray_origin - ray_vector_normalized.scale(t_parameter),
+            distance: t_parameter.abs(),
+        })
+    }
+}
+
+#[derive(Debug, Clone, Copy, PartialEq)]
+pub struct PointOnLine {
+    clamped: Point3<f32>,
+    unclamped: Point3<f32>,
+}
+
+/// Checks if a point lies on an infinite line.
+fn is_point_on_line_unclamped(
+    point: &Point3<f32>,
+    line_start: &Point3<f32>,
+    line_end: &Point3<f32>,
+) -> bool {
+    let line_start_to_point = point - line_start;
+    let line_start_to_end = line_end - line_start;
+    point == line_start
+        || point == line_end
+        || approx::relative_eq!(
+            line_start_to_point
+                .normalize()
+                .dot(&line_start_to_end.normalize())
+                .abs(),
+            1.0
+        )
+}
+
+/// Checks if a point lies on a line between two points.
+fn is_point_on_line_clamped(
+    point: &Point3<f32>,
+    line_start: &Point3<f32>,
+    line_end: &Point3<f32>,
+) -> bool {
+    let line_length_squared = nalgebra::distance_squared(line_start, line_end);
+    point == line_start
+        || point == line_end
+        || is_point_on_line_unclamped(point, line_start, line_end)
+            && nalgebra::distance_squared(line_start, point) <= line_length_squared
+            && nalgebra::distance_squared(line_end, point) <= line_length_squared
+}
+
+/// Pulls arbitrary point to an arbitrary line.
+///
+/// Returns both, a clamped point on the line and an unclamped points on an
+/// endless ray.
+///
+/// https://stackoverflow.com/questions/3120357/get-closest-point-to-a-line
+pub fn pull_point_to_line(
+    point: &Point3<f32>,
+    line_start: &Point3<f32>,
+    line_end: &Point3<f32>,
+) -> PointOnLine {
+    if is_point_on_line_clamped(point, line_start, line_end) {
+        return PointOnLine {
+            clamped: *point,
+            unclamped: *point,
+        };
+    }
+    let start_to_point = point - line_start;
+    let start_to_end = line_end - line_start;
+
+    let square_magnitude_start_to_end = nalgebra::distance_squared(line_start, line_end);
+    let start_to_point_dot_start_to_end = start_to_point.dot(&start_to_end);
+    let line_parameter = start_to_point_dot_start_to_end / square_magnitude_start_to_end;
+
+    let closest_point_on_line_unclamped =
+        Point3::from(line_start.coords.lerp(&line_end.coords, line_parameter));
+    let closest_point_on_line_clamped = if line_parameter < 0.0 {
+        *line_start
+    } else if line_parameter > 1.0 {
+        *line_end
+    } else {
+        closest_point_on_line_unclamped
+    };
+
+    PointOnLine {
+        clamped: closest_point_on_line_clamped,
+        unclamped: closest_point_on_line_unclamped,
+    }
+}
+
+#[derive(Debug, Clone, Copy, PartialEq)]
+pub struct PulledPointWithDistance {
+    point: Point3<f32>,
+    distance: f32,
+}
+
+/// Pulls arbitrary point to the closest point of a mesh geometry.
+///
+/// Cast a ray from the point perpendicular to each mesh face and if there is an
+/// intersection, add it to the list. Also measure a distance to the closest
+/// point on each mesh geometry edge. Pick the closest point of them all as the
+/// pulled point.
+#[allow(dead_code)]
+pub fn pull_point_to_mesh(
+    point: &Point3<f32>,
+    geometry: &Geometry,
+    unoriented_edges: &[UnorientedEdge],
+) -> PulledPointWithDistance {
+    let vertices = geometry.vertices();
+    let all_mesh_faces_with_normals = geometry.faces().iter().map(|Face::Triangle(t_f)| {
+        let face_vertices = (
+            &vertices[cast_usize(t_f.vertices.0)],
+            &vertices[cast_usize(t_f.vertices.1)],
+            &vertices[cast_usize(t_f.vertices.2)],
+        );
+        (
+            face_vertices,
+            geometry::compute_triangle_normal(face_vertices.0, face_vertices.1, face_vertices.2),
+        )
+    });
+    let points_pulled_to_faces =
+        all_mesh_faces_with_normals.filter_map(|(face_vertices, face_normal)| {
+            ray_intersects_triangle(point, &(-1.0 * face_normal), face_vertices)
+        });
+
+    let points_pulled_to_edges = unoriented_edges.iter().map(|u_e| {
+        let closest_point = pull_point_to_line(
+            point,
+            &vertices[cast_usize(u_e.0.vertices.0)],
+            &vertices[cast_usize(u_e.0.vertices.1)],
+        );
+        PulledPointWithDistance {
+            point: closest_point.clamped,
+            distance: nalgebra::distance(point, &closest_point.clamped),
+        }
+    });
+
+    let mut all_pulled_points = points_pulled_to_faces.chain(points_pulled_to_edges);
+
+    let mut closest_pulled_point = all_pulled_points.next().expect("No pulled point found");
+    for current_pulled_point in all_pulled_points {
+        if current_pulled_point.distance < closest_pulled_point.distance {
+            closest_pulled_point = current_pulled_point;
+        }
+    }
+
+    closest_pulled_point
+}
+
+/// Pulls arbitrary point to the closest point of a plane.
+///
+/// Cast a ray from the point perpendicular to the plane and calculate their
+/// intersection.
+#[allow(dead_code)]
+pub fn pull_point_to_plane(point: &Point3<f32>, plane: &Plane) -> PulledPointWithDistance {
+    ray_intersects_plane(point, &plane.normal(), plane)
+        .expect("The normal is parallel to its plane")
+}
+
+#[cfg(test)]
+mod tests {
+    use crate::geometry;
+
+    use super::*;
+
+    #[test]
+    fn test_vertex_tools_to_barycentric_for_point_inside() {
+        let triangle_points = (
+            &Point2::new(0.0, 1.0),
+            &Point2::new(-0.866025, -0.5),
+            &Point2::new(0.866025, -0.5),
+        );
+
+        let test_point = Point2::new(0.0, 0.0);
+        let barycentric_calculated = to_barycentric(
+            triangle_points.0,
+            triangle_points.1,
+            triangle_points.2,
+            &test_point,
+        )
+        .expect("Could not calculate the barycentric coords");
+
+        let barycentric_correct = Point3::new(0.333333, 0.333333, 0.333333);
+
+        assert!(barycentric_calculated.coords.relative_eq(
+            &barycentric_correct.coords,
+            0.001,
+            0.001
+        ));
+    }
+
+    #[test]
+    fn test_vertex_tools_to_barycentric_for_point_outside() {
+        let triangle_points = (
+            &Point2::new(0.0, 1.0),
+            &Point2::new(-0.866025, -0.5),
+            &Point2::new(0.866025, -0.5),
+        );
+
+        let test_point = Point2::new(0.0, 2.0);
+        let barycentric_calculated = to_barycentric(
+            triangle_points.0,
+            triangle_points.1,
+            triangle_points.2,
+            &test_point,
+        )
+        .expect("Could not calculate the barycentric coords");
+
+        let barycentric_correct = Point3::new(1.6666667, -0.33333334, -0.33333334);
+
+        assert!(barycentric_calculated.coords.relative_eq(
+            &barycentric_correct.coords,
+            0.001,
+            0.001
+        ));
+    }
+
+    #[test]
+    fn test_vertex_tools_is_point_in_triangle_returns_true_for_point_inside() {
+        let triangle_points = (
+            &Point3::new(0.0, 1.0, 0.0),
+            &Point3::new(-0.866025, -0.5, 0.0),
+            &Point3::new(0.866025, -0.5, 0.0),
+        );
+
+        let test_point = Point3::new(0.0, 0.0, 0.0);
+
+        assert!(is_point_in_triangle(&test_point, triangle_points));
+    }
+
+    #[test]
+    fn test_vertex_tools_is_point_in_triangle_returns_false_for_point_outside() {
+        let triangle_points = (
+            &Point3::new(0.0, 1.0, 0.0),
+            &Point3::new(-0.866025, -0.5, 0.0),
+            &Point3::new(0.866025, -0.5, 0.0),
+        );
+
+        let test_point = Point3::new(0.0, 2.0, 0.0);
+
+        assert!(!is_point_in_triangle(&test_point, triangle_points));
+    }
+
+    #[test]
+    fn test_vertex_tools_is_point_in_triangle_returns_false_for_point_above() {
+        let triangle_points = (
+            &Point3::new(0.0, 1.0, 0.0),
+            &Point3::new(-0.866025, -0.5, 0.0),
+            &Point3::new(0.866025, -0.5, 0.0),
+        );
+
+        let test_point = Point3::new(0.0, 0.0, 1.0);
+
+        assert!(!is_point_in_triangle(&test_point, triangle_points));
+    }
+
+    #[test]
+    fn test_vertex_tools_ray_intersects_triangle_for_horizontal_triangle_and_point_inside_returns_identical(
+    ) {
+        let face_points = (
+            &Point3::new(0.0, 1.0, 0.0),
+            &Point3::new(-0.866025, -0.5, 0.0),
+            &Point3::new(0.866025, -0.5, 0.0),
+        );
+
+        let ray_origin = Point3::new(0.0, 0.0, 0.0);
+        let ray_vector = Vector3::new(0.0, 0.0, 0.0);
+
+        let point_on_triangle_calculated =
+            ray_intersects_triangle(&ray_origin, &ray_vector, face_points)
+                .expect("Point is not on the triangle.");
+
+        assert_eq!(point_on_triangle_calculated.point, ray_origin);
+        assert_eq!(point_on_triangle_calculated.distance, 0.0);
+    }
+
+    #[test]
+    fn test_vertex_tools_ray_intersects_triangle_for_horizontal_triangle_returns_point_inside() {
+        let face_points = (
+            &Point3::new(0.0, 1.0, 0.0),
+            &Point3::new(-0.866025, -0.5, 0.0),
+            &Point3::new(0.866025, -0.5, 0.0),
+        );
+
+        let ray_origin = Point3::new(0.25, 0.25, 0.25);
+        let ray_vector = Vector3::new(0.0, 0.0, -1.0);
+
+        let point_on_triangle_correct = Point3::new(0.25, 0.25, 0.0);
+        let distance_correct = nalgebra::distance(&ray_origin, &point_on_triangle_correct);
+
+        let point_on_triangle_calculated =
+            ray_intersects_triangle(&ray_origin, &ray_vector, face_points)
+                .expect("Point is not on the triangle.");
+
+        assert_eq!(
+            point_on_triangle_calculated.point,
+            point_on_triangle_correct
+        );
+        assert_eq!(point_on_triangle_calculated.distance, distance_correct);
+    }
+
+    #[test]
+    fn test_vertex_tools_ray_intersects_triangle_for_horizontal_triangle_returns_none_because_ray_misses(
+    ) {
+        let face_points = (
+            &Point3::new(0.0, 1.0, 0.0),
+            &Point3::new(-0.866025, -0.5, 0.0),
+            &Point3::new(0.866025, -0.5, 0.0),
+        );
+
+        let ray_origin = Point3::new(1.25, 0.25, 0.25);
+        let ray_vector = Vector3::new(0.0, 0.0, -1.0);
+
+        let point_on_triangle_calculated =
+            ray_intersects_triangle(&ray_origin, &ray_vector, face_points);
+
+        // There is no intersection of the triangle and ray
+        assert_eq!(None, point_on_triangle_calculated);
+    }
+
+    #[test]
+    fn test_vertex_tools_ray_intersects_triangle_for_horizontal_triangle_returns_none_because_ray_parallel(
+    ) {
+        let face_points = (
+            &Point3::new(0.0, 1.0, 0.0),
+            &Point3::new(-0.866025, -0.5, 0.0),
+            &Point3::new(0.866025, -0.5, 0.0),
+        );
+
+        let ray_origin = Point3::new(0.25, 0.25, 0.25);
+        let ray_vector = Vector3::new(1.0, 0.0, 0.0);
+
+        let point_on_triangle_calculated =
+            ray_intersects_triangle(&ray_origin, &ray_vector, face_points);
+
+        // There is no intersection of the triangle and ray
+        assert_eq!(None, point_on_triangle_calculated);
+    }
+
+    #[test]
+    fn test_vertex_tools_ray_intersects_triangle_for_arbitrary_triangle_returns_point_inside() {
+        let face_points = (
+            &Point3::new(0.268023, 0.8302, 0.392469),
+            &Point3::new(-0.870844, -0.462665, 0.215034),
+            &Point3::new(0.334798, -0.197734, -0.999972),
+        );
+
+        let ray_origin = Point3::new(0.25, 0.25, 0.25);
+        let ray_vector = Vector3::new(-0.622709, 0.614937, -0.483823);
+
+        let point_on_triangle_correct = Point3::new(0.07773773, 0.42011225, 0.11615828);
+        let distance_correct = nalgebra::distance(&ray_origin, &point_on_triangle_correct);
+
+        let point_on_triangle_calculated =
+            ray_intersects_triangle(&ray_origin, &ray_vector, face_points)
+                .expect("Point is not on the triangle.");
+
+        assert_eq!(
+            point_on_triangle_calculated.point,
+            point_on_triangle_correct
+        );
+        assert_eq!(point_on_triangle_calculated.distance, distance_correct);
+    }
+
+    #[test]
+    fn test_vertex_tools_ray_intersects_triangle_for_horizontal_triangle_returns_self_for_point_inside(
+    ) {
+        let face_points = (
+            &Point3::new(0.0, 1.0, 0.0),
+            &Point3::new(-0.866025, -0.5, 0.0),
+            &Point3::new(0.866025, -0.5, 0.0),
+        );
+
+        let ray_origin = Point3::new(0.0, 0.0, 0.0);
+        let ray_vector = Vector3::new(0.0, 0.0, -1.0);
+
+        let point_on_triangle_calculated =
+            ray_intersects_triangle(&ray_origin, &ray_vector, face_points)
+                .expect("Point is not on the triangle.");
+
+        assert_eq!(point_on_triangle_calculated.point, ray_origin);
+        assert_eq!(point_on_triangle_calculated.distance, 0.0);
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_point_to_line_for_point_pulled_to_center() {
+        let line_start = &Point3::new(-1.0, 0.0, 0.0);
+        let line_end = &Point3::new(1.0, 0.0, 0.0);
+        let test_point = Point3::new(0.0, 1.0, 1.0);
+
+        let point_on_line_clamped_correct = Point3::new(0.0, 0.0, 0.0);
+        let point_on_line_unclamped_correct = Point3::new(0.0, 0.0, 0.0);
+
+        let point_on_line_calculated = pull_point_to_line(&test_point, line_start, line_end);
+
+        assert_eq!(
+            point_on_line_clamped_correct,
+            point_on_line_calculated.clamped
+        );
+        assert_eq!(
+            point_on_line_unclamped_correct,
+            point_on_line_calculated.unclamped
+        );
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_point_to_line_for_point_pulled_below_start() {
+        let line_start = &Point3::new(-1.0, 0.0, 0.0);
+        let line_end = &Point3::new(1.0, 0.0, 0.0);
+        let test_point = Point3::new(-2.0, 1.0, 1.0);
+
+        let point_on_line_clamped_correct = Point3::new(-1.0, 0.0, 0.0);
+        let point_on_line_unclamped_correct = Point3::new(-2.0, 0.0, 0.0);
+
+        let point_on_line_calculated = pull_point_to_line(&test_point, line_start, line_end);
+
+        assert_eq!(
+            point_on_line_clamped_correct,
+            point_on_line_calculated.clamped
+        );
+        assert_eq!(
+            point_on_line_unclamped_correct,
+            point_on_line_calculated.unclamped
+        );
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_point_to_line_for_point_pulled_beyond_end() {
+        let line_start = &Point3::new(-1.0, 0.0, 0.0);
+        let line_end = &Point3::new(1.0, 0.0, 0.0);
+        let test_point = Point3::new(2.0, 1.0, 1.0);
+
+        let point_on_line_clamped_correct = Point3::new(1.0, 0.0, 0.0);
+        let point_on_line_unclamped_correct = Point3::new(2.0, 0.0, 0.0);
+
+        let point_on_line_calculated = pull_point_to_line(&test_point, line_start, line_end);
+
+        assert_eq!(
+            point_on_line_clamped_correct,
+            point_on_line_calculated.clamped
+        );
+        assert_eq!(
+            point_on_line_unclamped_correct,
+            point_on_line_calculated.unclamped
+        );
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_point_to_line_for_point_on_the_line() {
+        let line_start = &Point3::new(-1.0, 0.0, 0.0);
+        let line_end = &Point3::new(1.0, 0.0, 0.0);
+        let test_point = Point3::new(0.0, 0.0, 0.0);
+
+        let point_on_line_clamped_correct = Point3::new(0.0, 0.0, 0.0);
+        let point_on_line_unclamped_correct = Point3::new(0.0, 0.0, 0.0);
+
+        let point_on_line_calculated = pull_point_to_line(&test_point, line_start, line_end);
+
+        assert_eq!(
+            point_on_line_clamped_correct,
+            point_on_line_calculated.clamped
+        );
+        assert_eq!(
+            point_on_line_unclamped_correct,
+            point_on_line_calculated.unclamped
+        );
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_point_to_mesh_cube_point_inside_left() {
+        let cube_geometry = geometry::cube_sharp_geometry([0.0, 0.0, 0.0], 1.0);
+        let test_point = Point3::new(-0.25, 0.0, 0.0);
+        let unoriented_edges: Vec<_> = cube_geometry.unoriented_edges_iter().collect();
+
+        let point_on_mesh_correct = Point3::new(-1.0, 0.0, 0.0);
+        let pulled_point_on_mesh_calculated =
+            pull_point_to_mesh(&test_point, &cube_geometry, &unoriented_edges);
+
+        assert_eq!(point_on_mesh_correct, pulled_point_on_mesh_calculated.point);
+        assert_eq!(0.75, pulled_point_on_mesh_calculated.distance);
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_point_to_mesh_cube_point_inside_top_front_right() {
+        let cube_geometry = geometry::cube_sharp_geometry([0.0, 0.0, 0.0], 1.0);
+        let test_point = Point3::new(0.25, 0.25, 0.25);
+        let unoriented_edges: Vec<_> = cube_geometry.unoriented_edges_iter().collect();
+
+        // any fo the following points on mesh would be correct
+        let points_on_mesh_correct = vec![
+            Point3::new(1.0, 0.25, 0.25),
+            Point3::new(0.25, 1.0, 0.25),
+            Point3::new(0.25, 0.25, 1.0),
+        ];
+        let pulled_point_on_mesh_calculated =
+            pull_point_to_mesh(&test_point, &cube_geometry, &unoriented_edges);
+
+        assert!(points_on_mesh_correct
+            .iter()
+            .any(|p| *p == pulled_point_on_mesh_calculated.point));
+
+        assert_eq!(0.75, pulled_point_on_mesh_calculated.distance);
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_point_to_mesh_cube_point_outside_top_front_right() {
+        let cube_geometry = geometry::cube_sharp_geometry([0.0, 0.0, 0.0], 1.0);
+        let test_point = Point3::new(1.25, 1.25, 1.25);
+        let unoriented_edges: Vec<_> = cube_geometry.unoriented_edges_iter().collect();
+
+        // corner
+        let point_on_mesh_correct = Point3::new(1.0, 1.0, 1.0);
+        let pulled_point_on_mesh_calculated =
+            pull_point_to_mesh(&test_point, &cube_geometry, &unoriented_edges);
+
+        assert_eq!(point_on_mesh_correct, pulled_point_on_mesh_calculated.point);
+        assert_eq!(
+            nalgebra::distance(&test_point, &pulled_point_on_mesh_calculated.point),
+            pulled_point_on_mesh_calculated.distance
+        );
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_point_to_mesh_cube_point_outside_front_right() {
+        let cube_geometry = geometry::cube_sharp_geometry([0.0, 0.0, 0.0], 1.0);
+        let test_point = Point3::new(1.25, 1.25, 0.25);
+        let unoriented_edges: Vec<_> = cube_geometry.unoriented_edges_iter().collect();
+
+        // on the edge
+        let point_on_mesh_correct = Point3::new(1.0, 1.0, 0.25);
+        let pulled_point_on_mesh_calculated =
+            pull_point_to_mesh(&test_point, &cube_geometry, &unoriented_edges);
+
+        assert_eq!(point_on_mesh_correct, pulled_point_on_mesh_calculated.point);
+        assert_eq!(
+            nalgebra::distance(&test_point, &pulled_point_on_mesh_calculated.point),
+            pulled_point_on_mesh_calculated.distance
+        );
+    }
+
+    #[test]
+    fn test_vertex_tools_is_point_on_plane_returns_true_for_point_on_plane() {
+        let plane_origin = Point3::new(1.0, 0.0, 0.0);
+        let plane_normal = Vector3::new(1.0, 0.0, 0.0);
+        let test_point = Point3::new(1.0, 1.0, 1.0);
+
+        assert!(is_point_on_plane(&test_point, &plane_origin, &plane_normal));
+    }
+
+    #[test]
+    fn test_vertex_tools_is_point_on_plane_returns_false_for_point_elsewhere() {
+        let plane_origin = Point3::new(1.0, 0.0, 0.0);
+        let plane_normal = Vector3::new(1.0, 0.0, 0.0);
+        let test_point = Point3::new(2.0, 1.0, 1.0);
+
+        assert!(!is_point_on_plane(
+            &test_point,
+            &plane_origin,
+            &plane_normal
+        ));
+    }
+
+    #[test]
+    fn test_vertex_tools_ray_intersects_plane_seed_2() {
+        let normal = Vector3::new(0.505588, 0.843833, -0.179794);
+        let ray_vector = Vector3::new(-0.708348, 0.05881, -0.703409);
+        let ray_origin = Point3::new(0.328762, 0.9441, 0.02429);
+
+        let plane = Plane::from_origin_and_normal(&Point3::origin(), &normal);
+
+        let point_on_plane_correct = Point3::new(-3.401022, 1.2537622, -3.679488);
+        let distance_correct = nalgebra::distance(&ray_origin, &point_on_plane_correct);
+
+        let point_on_plane_calculated = ray_intersects_plane(&ray_origin, &ray_vector, &plane)
+            .expect("The ray doesn't intersect the plane");
+
+        assert_eq!(point_on_plane_calculated.point, point_on_plane_correct);
+        assert_eq!(point_on_plane_calculated.distance, distance_correct);
+    }
+
+    #[test]
+    fn test_vertex_tools_ray_intersects_plane_seed_12() {
+        let normal = Vector3::new(-0.987928, 0.02117, -0.15346);
+        let ray_vector = Vector3::new(0.515951, 0.520597, -0.680275);
+        let ray_origin = Point3::new(0.758986, -0.648866, 0.053964);
+
+        let plane = Plane::from_origin_and_normal(&Point3::origin(), &normal);
+
+        let point_on_plane_correct = Point3::new(-0.2509706, -1.667917, 1.3855793);
+        let distance_correct = nalgebra::distance(&ray_origin, &point_on_plane_correct);
+
+        let point_on_plane_calculated = ray_intersects_plane(&ray_origin, &ray_vector, &plane)
+            .expect("The ray doesn't intersect the plane");
+
+        assert_eq!(point_on_plane_calculated.point, point_on_plane_correct);
+        assert!(approx::relative_eq!(
+            point_on_plane_calculated.distance,
+            distance_correct
+        ));
+    }
+
+    #[test]
+    fn test_vertex_tools_ray_intersects_plane_returns_none_because_ray_parallel_to_plane() {
+        let normal = Vector3::new(0.0, 0.0, 1.0);
+        let ray_vector = Vector3::new(1.0, 1.0, 0.0);
+        let ray_origin = Point3::new(0.0, 0.0, 1.0);
+
+        let plane = Plane::from_origin_and_normal(&Point3::origin(), &normal);
+
+        let point_on_plane_calculated = ray_intersects_plane(&ray_origin, &ray_vector, &plane);
+
+        assert_eq!(point_on_plane_calculated, None);
+    }
+
+    #[test]
+    fn test_vertex_tools_ray_intersects_plane_returns_self_for_point_on_plane() {
+        let normal = Vector3::new(0.0, 0.0, 1.0);
+        let ray_vector = Vector3::new(1.0, 1.0, 1.0);
+        let ray_origin = Point3::new(1.0, 1.0, 0.0);
+
+        let plane = Plane::from_origin_and_normal(&Point3::origin(), &normal);
+
+        let point_on_plane_calculated = ray_intersects_plane(&ray_origin, &ray_vector, &plane)
+            .expect("The ray doesn't intersect the plane");
+
+        assert_eq!(point_on_plane_calculated.point, ray_origin);
+        assert!(approx::relative_eq!(
+            point_on_plane_calculated.distance,
+            0.0,
+        ));
+    }
+
+    #[test]
+    fn test_vertex_tools_ray_intersects_plane_returns_self_for_point_on_plane_and_parallel_ray() {
+        let normal = Vector3::new(0.0, 0.0, 1.0);
+        let ray_vector = Vector3::new(1.0, 1.0, 0.0);
+        let ray_origin = Point3::new(1.0, 1.0, 0.0);
+
+        let plane = Plane::from_origin_and_normal(&Point3::origin(), &normal);
+
+        let point_on_plane_calculated = ray_intersects_plane(&ray_origin, &ray_vector, &plane)
+            .expect("The ray doesn't intersect the plane");
+
+        assert_eq!(point_on_plane_calculated.point, ray_origin);
+        assert!(approx::relative_eq!(
+            point_on_plane_calculated.distance,
+            0.0,
+        ));
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_point_to_plane_for_point_on_plane_and_horizontal_plane() {
+        let test_point: Point3<f32> = Point3::origin();
+        let test_plane =
+            Plane::from_origin_and_normal(&Point3::origin(), &Vector3::new(0.0, 0.0, 1.0));
+
+        let point_pulled_to_plane_calculated = pull_point_to_plane(&test_point, &test_plane);
+
+        assert_eq!(point_pulled_to_plane_calculated.point, test_point);
+        assert_eq!(point_pulled_to_plane_calculated.distance, 0.0);
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_point_to_plane_for_point_on_plane_and_vertical_plane() {
+        let test_point: Point3<f32> = Point3::origin();
+        let test_plane =
+            Plane::from_origin_and_normal(&Point3::origin(), &Vector3::new(1.0, 0.0, 0.0));
+
+        let point_pulled_to_plane_calculated = pull_point_to_plane(&test_point, &test_plane);
+
+        assert_eq!(point_pulled_to_plane_calculated.point, test_point);
+        assert_eq!(point_pulled_to_plane_calculated.distance, 0.0);
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_point_to_plane_for_point_above_plane_and_horizontal_plane() {
+        let test_point = Point3::new(0.0, 0.0, 1.0);
+        let test_plane =
+            Plane::from_origin_and_normal(&Point3::origin(), &Vector3::new(0.0, 0.0, 1.0));
+
+        let point_pulled_to_plane_calculated = pull_point_to_plane(&test_point, &test_plane);
+
+        assert_eq!(
+            point_pulled_to_plane_calculated.point,
+            Point3::new(0.0, 0.0, 0.0)
+        );
+        assert_eq!(point_pulled_to_plane_calculated.distance, 1.0);
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_point_to_plane_for_arbitrary_point_and_arbitrary_plane() {
+        let test_point = Point3::new(2.5, 4.2, 1.8);
+        let test_plane = Plane::from_origin_and_normal(&Point3::origin(), &test_point.coords);
+
+        let distance_correct = nalgebra::distance(&test_point, &Point3::origin());
+
+        let point_pulled_to_plane_calculated = pull_point_to_plane(&test_point, &test_plane);
+
+        assert!(point_pulled_to_plane_calculated.point.coords.relative_eq(
+            &Vector3::new(0.0, 0.0, 0.0),
+            0.001,
+            0.001,
+        ));
+        assert_eq!(point_pulled_to_plane_calculated.distance, distance_correct);
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_is_point_on_line_unclamped_returns_true_for_point_on_start() {
+        let line_start = Point3::new(-1.0, -1.0, -1.0);
+        let line_end = Point3::new(1.0, 1.0, 1.0);
+        let test_point = Point3::new(-1.0, -1.0, -1.0);
+
+        assert!(is_point_on_line_unclamped(
+            &test_point,
+            &line_start,
+            &line_end
+        ));
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_is_point_on_line_unclamped_returns_true_for_point_on_end() {
+        let line_start = Point3::new(-1.0, -1.0, -1.0);
+        let line_end = Point3::new(1.0, 1.0, 1.0);
+        let test_point = Point3::new(1.0, 1.0, 1.0);
+
+        assert!(is_point_on_line_unclamped(
+            &test_point,
+            &line_start,
+            &line_end
+        ));
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_is_point_on_line_unclamped_returns_true_for_point_in_the_middle() {
+        let line_start = Point3::new(-1.0, -1.0, -1.0);
+        let line_end = Point3::new(1.0, 1.0, 1.0);
+        let test_point = Point3::new(0.0, 0.0, 0.0);
+
+        assert!(is_point_on_line_unclamped(
+            &test_point,
+            &line_start,
+            &line_end
+        ));
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_is_point_on_line_unclamped_returns_true_for_point_before() {
+        let line_start = Point3::new(-1.0, -1.0, -1.0);
+        let line_end = Point3::new(1.0, 1.0, 1.0);
+        let test_point = Point3::new(-2.0, -2.0, -2.0);
+
+        assert!(is_point_on_line_unclamped(
+            &test_point,
+            &line_start,
+            &line_end
+        ));
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_is_point_on_line_unclamped_returns_true_for_point_after() {
+        let line_start = Point3::new(-1.0, -1.0, -1.0);
+        let line_end = Point3::new(1.0, 1.0, 1.0);
+        let test_point = Point3::new(2.0, 2.0, 2.0);
+
+        assert!(is_point_on_line_unclamped(
+            &test_point,
+            &line_start,
+            &line_end
+        ));
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_is_point_on_line_unclamped_returns_false_for_point_elsewhere() {
+        let line_start = Point3::new(-1.0, -1.0, -1.0);
+        let line_end = Point3::new(1.0, 1.0, 1.0);
+        let test_point = Point3::new(3.0, 2.0, 1.0);
+
+        assert!(!is_point_on_line_unclamped(
+            &test_point,
+            &line_start,
+            &line_end
+        ));
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_is_point_on_line_clamped_returns_true_for_point_on_start() {
+        let line_start = Point3::new(-1.0, -1.0, -1.0);
+        let line_end = Point3::new(1.0, 1.0, 1.0);
+        let test_point = Point3::new(-1.0, -1.0, -1.0);
+
+        assert!(is_point_on_line_clamped(
+            &test_point,
+            &line_start,
+            &line_end
+        ));
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_is_point_on_line_clamped_returns_true_for_point_on_end() {
+        let line_start = Point3::new(-1.0, -1.0, -1.0);
+        let line_end = Point3::new(1.0, 1.0, 1.0);
+        let test_point = Point3::new(1.0, 1.0, 1.0);
+
+        assert!(is_point_on_line_clamped(
+            &test_point,
+            &line_start,
+            &line_end
+        ));
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_is_point_on_line_clamped_returns_true_for_point_in_the_middle() {
+        let line_start = Point3::new(-1.0, -1.0, -1.0);
+        let line_end = Point3::new(1.0, 1.0, 1.0);
+        let test_point = Point3::new(0.0, 0.0, 0.0);
+
+        assert!(is_point_on_line_clamped(
+            &test_point,
+            &line_start,
+            &line_end
+        ));
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_is_point_on_line_clamped_returns_false_for_point_before() {
+        let line_start = Point3::new(-1.0, -1.0, -1.0);
+        let line_end = Point3::new(1.0, 1.0, 1.0);
+        let test_point = Point3::new(-2.0, -2.0, -2.0);
+
+        assert!(!is_point_on_line_clamped(
+            &test_point,
+            &line_start,
+            &line_end
+        ));
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_is_point_on_line_clamped_returns_false_for_point_after() {
+        let line_start = Point3::new(-1.0, -1.0, -1.0);
+        let line_end = Point3::new(1.0, 1.0, 1.0);
+        let test_point = Point3::new(2.0, 2.0, 2.0);
+
+        assert!(!is_point_on_line_clamped(
+            &test_point,
+            &line_start,
+            &line_end
+        ));
+    }
+
+    #[test]
+    fn test_vertex_tools_pull_is_point_on_line_clamped_returns_false_for_point_elsewhere() {
+        let line_start = Point3::new(-1.0, -1.0, -1.0);
+        let line_end = Point3::new(1.0, 1.0, 1.0);
+        let test_point = Point3::new(3.0, 2.0, 1.0);
+
+        assert!(!is_point_on_line_clamped(
+            &test_point,
+            &line_start,
+            &line_end
+        ));
+    }
+}
diff --git a/tests/fixtures/valid_2.obj b/tests/fixtures/valid_2.obj
index d5db8cb..de3e83e 100644
--- a/tests/fixtures/valid_2.obj
+++ b/tests/fixtures/valid_2.obj
@@ -1,7 +1,5 @@
-o Triangle
-
+o Quad
 v 0 1 0
 v 0 0 0
 v 1 0 0
-
-f 1 2 3
+v 1 1 0
